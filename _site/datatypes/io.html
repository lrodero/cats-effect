<!DOCTYPE html><html><head><title>Cats Effect: IO</title><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="Cats Effect contributors" /><meta name="description" content="The IO Monad for Scala" /><meta name="og:image" content="/cats-effect/img/poster.png" /><meta name="image" property="og:image" content="/cats-effect/img/poster.png" /><meta name="og:title" content="Cats Effect: IO" /><meta name="title" property="og:title" content="Cats Effect: IO" /><meta name="og:site_name" content="Cats Effect" /><meta name="og:url" content="https://typelevel.org/cats-effect/" /><meta name="og:type" content="website" /><meta name="og:description" content="The IO Monad for Scala" /><link rel="icon" type="image/png" href="/cats-effect/img/favicon.png" /><meta name="twitter:title" content="Cats Effect: IO" /><meta name="twitter:image" content="/cats-effect/img/poster.png" /><meta name="twitter:description" content="The IO Monad for Scala" /><meta name="twitter:card" content="summary_large_image" /><meta name="twitter:creator" content="@typelevel" /><link rel="icon" type="image/png" sizes="16x16" href="/cats-effect/img/favicon16x16.png" /><link rel="icon" type="image/png" sizes="24x24" href="/cats-effect/img/favicon24x24.png" /><link rel="icon" type="image/png" sizes="32x32" href="/cats-effect/img/favicon32x32.png" /><link rel="icon" type="image/png" sizes="48x48" href="/cats-effect/img/favicon48x48.png" /><link rel="icon" type="image/png" sizes="57x57" href="/cats-effect/img/favicon57x57.png" /><link rel="icon" type="image/png" sizes="60x60" href="/cats-effect/img/favicon60x60.png" /><link rel="icon" type="image/png" sizes="64x64" href="/cats-effect/img/favicon64x64.png" /><link rel="icon" type="image/png" sizes="70x70" href="/cats-effect/img/favicon70x70.png" /><link rel="icon" type="image/png" sizes="72x72" href="/cats-effect/img/favicon72x72.png" /><link rel="icon" type="image/png" sizes="76x76" href="/cats-effect/img/favicon76x76.png" /><link rel="icon" type="image/png" sizes="96x96" href="/cats-effect/img/favicon96x96.png" /><link rel="icon" type="image/png" sizes="114x114" href="/cats-effect/img/favicon114x114.png" /><link rel="icon" type="image/png" sizes="120x120" href="/cats-effect/img/favicon120x120.png" /><link rel="icon" type="image/png" sizes="128x128" href="/cats-effect/img/favicon128x128.png" /><link rel="icon" type="image/png" sizes="144x144" href="/cats-effect/img/favicon144x144.png" /><link rel="icon" type="image/png" sizes="150x150" href="/cats-effect/img/favicon150x150.png" /><link rel="icon" type="image/png" sizes="152x152" href="/cats-effect/img/favicon152x152.png" /><link rel="icon" type="image/png" sizes="196x196" href="/cats-effect/img/favicon196x196.png" /><link rel="icon" type="image/png" sizes="310x310" href="/cats-effect/img/favicon310x310.png" /><link rel="icon" type="image/png" sizes="310x150" href="/cats-effect/img/favicon310x150.png" /><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" /><link rel="stylesheet" href="/cats-effect/highlight/styles/atom-one-light.css" /><link rel="stylesheet" href="/cats-effect/css/light-style.css" /><link rel="stylesheet" href="/cats-effect/css/toc.css" /></head><body class="docs"><div id="wrapper"><div id="sidebar-wrapper"><div id="sidebar-brand"><a href="/cats-effect/" class="brand"><div class="brand-wrapper"></div><span>Cats Effect</span></a><button id="main-toggle" class="sidebar-toggle"><span class="close"></span></button></div><div class="sidebar-nav"> <div class="sidebar-nav-item  open"><a href="/cats-effect/datatypes/" title="Data Types" class="drop-nested">Data Types</a><i class="fa fa-angle-right"></i><div class="sub-section"> <a href="/cats-effect/datatypes/io.html" title="IO" class="active">IO</a> <a href="/cats-effect/datatypes/syncio.html" title="SyncIO" class="">SyncIO</a> <a href="/cats-effect/datatypes/fiber.html" title="Fiber" class="">Fiber</a> <a href="/cats-effect/datatypes/resource.html" title="Resource" class="">Resource</a> <a href="/cats-effect/datatypes/clock.html" title="Clock" class="">Clock</a> <a href="/cats-effect/datatypes/contextshift.html" title="ContextShift" class="">ContextShift</a> <a href="/cats-effect/datatypes/timer.html" title="Timer" class="">Timer</a> <a href="/cats-effect/datatypes/ioapp.html" title="IOApp" class="">IOApp</a></div></div> <div class="sidebar-nav-item  "><a href="/cats-effect/concurrency/" title="Concurrency" class="drop-nested">Concurrency</a><i class="fa fa-angle-right"></i><div class="sub-section"> <a href="/cats-effect/concurrency/basics.html" title="Concurrency Basics" class="">Concurrency Basics</a> <a href="/cats-effect/concurrency/deferred.html" title="Deferred" class="">Deferred</a> <a href="/cats-effect/concurrency/mvar.html" title="MVar" class="">MVar</a> <a href="/cats-effect/concurrency/ref.html" title="Ref" class="">Ref</a> <a href="/cats-effect/concurrency/semaphore.html" title="Semaphore" class="">Semaphore</a></div></div> <div class="sidebar-nav-item  "><a href="/cats-effect/typeclasses/" title="Type Classes" class="drop-nested">Type Classes</a><i class="fa fa-angle-right"></i><div class="sub-section"> <a href="/cats-effect/typeclasses/bracket.html" title="Bracket" class="">Bracket</a> <a href="/cats-effect/typeclasses/sync.html" title="Sync" class="">Sync</a> <a href="/cats-effect/typeclasses/liftio.html" title="LiftIO" class="">LiftIO</a> <a href="/cats-effect/typeclasses/async.html" title="Async" class="">Async</a> <a href="/cats-effect/typeclasses/concurrent.html" title="Concurrent" class="">Concurrent</a> <a href="/cats-effect/typeclasses/effect.html" title="Effect" class="">Effect</a> <a href="/cats-effect/typeclasses/concurrent-effect.html" title="ConcurrentEffect" class="">ConcurrentEffect</a></div></div> <div class="sidebar-nav-item  "><a href="/cats-effect/tutorial/tutorial.html" title="Tutorial" class="">Tutorial</a></div> <div class="sidebar-nav-item  "><a href="/cats-effect/tracing/" title="Tracing" class="">Tracing</a></div></div></div><div id="page-content-wrapper"><div class="nav"><div class="container-fluid"><div class="row"><div class="col-lg-12"><div class="action-menu pull-left clearfix"><a href="#menu-toggle" id="menu-toggle"><i class="fa fa-bars" aria-hidden="true"></i></a></div><ul class="pull-right"><li id="gh-eyes-item" class="hidden-xs"><a href="https://github.com/typelevel/cats-effect" target="_blank" rel="noopener noreferrer"><i class="fa fa-eye"></i><span>Watchers<span id="eyes" class="label label-default">--</span></span></a></li><li id="gh-stars-item" class="hidden-xs"><a href="https://github.com/typelevel/cats-effect" target="_blank" rel="noopener noreferrer"><i class="fa fa-star-o"></i><span>Stars<span id="stars" class="label label-default">--</span></span></a></li></ul></div></div></div></div><div id="content" data-github-owner="typelevel" data-github-repo="cats-effect"><div class="content-wrapper"><section><h1>IO</h1>

<p>A data type for encoding side effects as pure values, capable of
expressing both synchronous and asynchronous computations.</p>

<nav role="navigation" id="toc"></nav>

<h2 id="introduction">Introduction</h2>

<p>A value of type <code class="highlighter-rouge">IO[A]</code> is a computation which, when evaluated, can
perform effects before returning a value of type <code class="highlighter-rouge">A</code>.</p>

<p><code class="highlighter-rouge">IO</code> values are pure, immutable values and thus preserves referential
transparency, being usable in functional programming. An <code class="highlighter-rouge">IO</code> is a
data structure that represents just a description of a side effectful
computation.</p>

<p><code class="highlighter-rouge">IO</code> can describe synchronous or asynchronous computations that:</p>

<ol>
  <li>on evaluation yield exactly one result</li>
  <li>can end in either success or failure and in case of failure
<code class="highlighter-rouge">flatMap</code> chains get short-circuited (<code class="highlighter-rouge">IO</code> implementing the algebra
of <code class="highlighter-rouge">MonadError</code>)</li>
  <li>can be canceled, but note this capability relies on the
user to provide cancellation logic</li>
</ol>

<p>Effects described via this abstraction are not evaluated until the
“end of the world”, which is to say, when one of the “unsafe” methods
are used. Effectful results are not memoized, meaning that memory
overhead is minimal (and no leaks), and also that a single effect may
be run multiple times in a referentially-transparent manner. For
example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.IO</span>

<span class="k">val</span> <span class="n">ioa</span> <span class="k">=</span> <span class="nc">IO</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">"hey!"</span><span class="o">)</span> <span class="o">}</span>

<span class="k">val</span> <span class="n">program</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
     <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">ioa</span>
     <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">ioa</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="o">()</span>

<span class="n">program</span><span class="o">.</span><span class="n">unsafeRunSync</span><span class="o">()</span>
<span class="c1">//=&gt; hey!
//=&gt; hey!
</span><span class="o">()</span>
</code></pre></div></div>

<p>The above example prints “hey!” twice, as the effect re-runs each time
it is sequenced in the monadic chain.</p>

<h3 id="on-referential-transparency-and-lazy-evaluation">On Referential Transparency and Lazy Evaluation</h3>

<p><code class="highlighter-rouge">IO</code> can suspend side effects and is thus a lazily evaluated data type, being many times compared with <code class="highlighter-rouge">Future</code> from the standard library and to understand the landscape in terms of the evaluation model (in Scala), consider this classification:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: center">Eager</th>
      <th style="text-align: center">Lazy</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><strong>Synchronous</strong></td>
      <td style="text-align: center">A</td>
      <td style="text-align: center">() =&gt; A</td>
    </tr>
    <tr>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"><a href="https://typelevel.org/cats/datatypes/eval.html">Eval[A]</a></td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>Asynchronous</strong></td>
      <td style="text-align: center">(A =&gt; Unit) =&gt; Unit</td>
      <td style="text-align: center">() =&gt; (A =&gt; Unit) =&gt; Unit</td>
    </tr>
    <tr>
      <td style="text-align: center"> </td>
      <td style="text-align: center">Future[A]</td>
      <td style="text-align: center">IO[A]</td>
    </tr>
  </tbody>
</table>

<p>In comparison with Scala’s <code class="highlighter-rouge">Future</code>, the <code class="highlighter-rouge">IO</code> data type preserves <em>referential transparency</em> even when dealing with side effects and is lazily evaluated. In an eager language like Scala, this is the difference between a result and the function producing it.</p>

<p>Similar with <code class="highlighter-rouge">Future</code>, with <code class="highlighter-rouge">IO</code> you can reason about the results of asynchronous processes, but due to its purity and laziness <code class="highlighter-rouge">IO</code> can be thought of as a specification (to be evaluated at the “<em>end of the world</em>”), yielding more control over the evaluation model and being more predictable, for example when dealing with sequencing vs parallelism, when composing multiple IOs or when dealing with failure.</p>

<p>Note laziness goes hand in hand with referential transparency. Consider this example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">{</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">addToGauge</span><span class="o">(</span><span class="mi">32</span><span class="o">)</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">addToGauge</span><span class="o">(</span><span class="mi">32</span><span class="o">)</span>
<span class="o">}</span> <span class="k">yield</span> <span class="o">()</span>
</code></pre></div></div>

<p>If we have referential transparency, we can rewrite that example as:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">task</span> <span class="k">=</span> <span class="n">addToGauge</span><span class="o">(</span><span class="mi">32</span><span class="o">)</span>

<span class="k">for</span> <span class="o">{</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">task</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">task</span>
<span class="o">}</span> <span class="k">yield</span> <span class="o">()</span>
</code></pre></div></div>

<p>This doesn’t work with <code class="highlighter-rouge">Future</code>, but works with <code class="highlighter-rouge">IO</code> and this ability is essential for <em>functional programming</em>.</p>

<h3 id="stack-safety">Stack Safety</h3>

<p><code class="highlighter-rouge">IO</code> is trampolined in its <code class="highlighter-rouge">flatMap</code> evaluation. This means that you
can safely call <code class="highlighter-rouge">flatMap</code> in a recursive function of arbitrary depth,
without fear of blowing the stack:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">fib</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=</span> <span class="mi">1</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">IO</span><span class="o">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">).</span><span class="n">flatMap</span> <span class="o">{</span> <span class="n">b2</span> <span class="k">=&gt;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> 
      <span class="n">fib</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">b2</span><span class="o">)</span>
    <span class="k">else</span> 
      <span class="nc">IO</span><span class="o">.</span><span class="n">pure</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">IO</code> implements all the typeclasses shown in the <a href="/cats-effect/typeclasses/">hierarchy</a>. Therefore
all those operations are available for <code class="highlighter-rouge">IO</code>, in addition to some
others.</p>

<h2 id="describing-effects">Describing Effects</h2>

<p><code class="highlighter-rouge">IO</code> is a potent abstraction that can efficiently describe multiple
kinds of effects:</p>

<h3 id="pure-values--iopure--iounit">Pure Values — IO.pure &amp; IO.unit</h3>

<p>You can lift pure values into <code class="highlighter-rouge">IO</code>, yielding <code class="highlighter-rouge">IO</code> values that are
“already evaluated”, the following function being defined on IO’s 
companion:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">pure</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
</code></pre></div></div>

<p>Note that the given parameter is passed by value, not by name.</p>

<p>For example we can lift a number (pure value) into <code class="highlighter-rouge">IO</code> and compose it
with another <code class="highlighter-rouge">IO</code> that wraps a side a effect in a safe manner, as
nothing is going to be executed:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IO</span><span class="o">.</span><span class="n">pure</span><span class="o">(</span><span class="mi">25</span><span class="o">).</span><span class="n">flatMap</span><span class="o">(</span><span class="n">n</span> <span class="k">=&gt;</span> <span class="nc">IO</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Number is: $n"</span><span class="o">)))</span>
</code></pre></div></div>

<p>It should be obvious that <code class="highlighter-rouge">IO.pure</code> cannot suspend side effects, because
<code class="highlighter-rouge">IO.pure</code> is eagerly evaluated, with the given parameter being passed
by value, so don’t do this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IO</span><span class="o">.</span><span class="n">pure</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="s">"THIS IS WRONG!"</span><span class="o">))</span>
</code></pre></div></div>

<p>In this case the <code class="highlighter-rouge">println</code> will trigger a side effect that is not
suspended in <code class="highlighter-rouge">IO</code> and given this code that probably is not our
intention.</p>

<p><code class="highlighter-rouge">IO.unit</code> is simply an alias for <code class="highlighter-rouge">IO.pure(())</code>, being a reusable
reference that you can use when an <code class="highlighter-rouge">IO[Unit]</code> value is required, but
you don’t need to trigger any other side effects:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">unit</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">.</span><span class="n">pure</span><span class="o">(())</span>
</code></pre></div></div>

<p>Given <code class="highlighter-rouge">IO[Unit]</code> is so prevalent in Scala code, the <code class="highlighter-rouge">Unit</code> type itself
being meant to signal completion of side effectful routines, this
proves useful as a shortcut and as an optimization, since the same
reference is returned.</p>

<h3 id="synchronous-effects--ioapply">Synchronous Effects — IO.apply</h3>

<p>It’s probably the most used builder and the equivalent of
<code class="highlighter-rouge">Sync[IO].delay</code>, describing <code class="highlighter-rouge">IO</code> operations that can be evaluated
immediately, on the current thread and call-stack:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">body</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
</code></pre></div></div>

<p>Note the given parameter is passed ‘‘by name’’, its execution being
“suspended” in the <code class="highlighter-rouge">IO</code> context.</p>

<p>An example would be reading / writing from / to the console, which on
top of the JVM uses blocking I/O, so their execution is immediate:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">putStrLn</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="n">value</span><span class="o">))</span>
<span class="k">val</span> <span class="n">readLn</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="n">scala</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="nc">StdIn</span><span class="o">.</span><span class="n">readLine</span><span class="o">())</span>
</code></pre></div></div>

<p>And then we can use that to model interactions with the console in a
purely functional way:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">{</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">putStrLn</span><span class="o">(</span><span class="s">"What's your name?"</span><span class="o">)</span>
  <span class="n">n</span> <span class="k">&lt;-</span> <span class="n">readLn</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">putStrLn</span><span class="o">(</span><span class="n">s</span><span class="s">"Hello, $n!"</span><span class="o">)</span>
<span class="o">}</span> <span class="k">yield</span> <span class="o">()</span>
</code></pre></div></div>

<h3 id="asynchronous-effects--ioasync--iocancelable">Asynchronous Effects — IO.async &amp; IO.cancelable</h3>

<p><code class="highlighter-rouge">IO</code> can describe asynchronous processes via the <code class="highlighter-rouge">IO.async</code> and
<code class="highlighter-rouge">IO.cancelable</code> builders.</p>

<p><code class="highlighter-rouge">IO.async</code> is the operation that complies with the laws of
<code class="highlighter-rouge">Async#async</code> (see <a href="/cats-effect/typeclasses/async.html">Async</a>) and can
describe simple asynchronous processes that cannot be canceled,
its signature being:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">async</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">k</span><span class="k">:</span> <span class="o">(</span><span class="kt">Either</span><span class="o">[</span><span class="kt">Throwable</span>, <span class="kt">A</span><span class="o">]</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
</code></pre></div></div>

<p>The provided registration function injects a callback that you can use
to signal either successful results (with <code class="highlighter-rouge">Right(a)</code>), or failures
(with <code class="highlighter-rouge">Left(error)</code>). Users can trigger whatever asynchronous side
effects are required, then use the injected callback to signal
completion.</p>

<p>For example, you don’t need to convert Scala’s <code class="highlighter-rouge">Future</code>, because you
already have a conversion operation defined in <code class="highlighter-rouge">IO.fromFuture</code>,
however the code for converting a <code class="highlighter-rouge">Future</code> would be straightforward:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.</span><span class="o">{</span><span class="nc">Future</span><span class="o">,</span> <span class="nc">ExecutionContext</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">scala.util.</span><span class="o">{</span><span class="nc">Success</span><span class="o">,</span> <span class="nc">Failure</span><span class="o">}</span>

<span class="k">def</span> <span class="n">convert</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Future</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">ec</span><span class="k">:</span> <span class="kt">ExecutionContext</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">IO</span><span class="o">.</span><span class="n">async</span> <span class="o">{</span> <span class="n">cb</span> <span class="k">=&gt;</span>
    <span class="c1">// This triggers evaluation of the by-name param and of onComplete, 
</span>    <span class="c1">// so it's OK to have side effects in this callback
</span>    <span class="n">fa</span><span class="o">.</span><span class="n">onComplete</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">cb</span><span class="o">(</span><span class="nc">Right</span><span class="o">(</span><span class="n">a</span><span class="o">))</span>
      <span class="k">case</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">cb</span><span class="o">(</span><span class="nc">Left</span><span class="o">(</span><span class="n">e</span><span class="o">))</span>
    <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div></div>

<h4 id="cancelable-processes">Cancelable Processes</h4>

<p>For building cancelable <code class="highlighter-rouge">IO</code> tasks you need to use the
<code class="highlighter-rouge">IO.cancelable</code> builder, this being compliant with
<code class="highlighter-rouge">Concurrent#cancelable</code> (see <a href="/cats-effect/typeclasses/concurrent.html">Concurrent</a>) 
and has this signature:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">cancelable</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">k</span><span class="k">:</span> <span class="o">(</span><span class="kt">Either</span><span class="o">[</span><span class="kt">Throwable</span>, <span class="kt">A</span><span class="o">]</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
</code></pre></div></div>

<p>So it is similar with <code class="highlighter-rouge">IO.async</code>, but in that registration function
the user is expected to provide an <code class="highlighter-rouge">IO[Unit]</code> that captures the
required cancellation logic.</p>

<p>Important: cancellation is the ability to interrupt an <code class="highlighter-rouge">IO</code> task before
completion, possibly releasing any acquired resources, useful in race
conditions to prevent leaks.</p>

<p>As example suppose we want to describe a <code class="highlighter-rouge">sleep</code> operation that
depends on Java’s <code class="highlighter-rouge">ScheduledExecutorService</code>, delaying a tick for a
certain time duration:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">java.util.concurrent.ScheduledExecutorService</span>
<span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">def</span> <span class="n">delayedTick</span><span class="o">(</span><span class="n">d</span><span class="k">:</span> <span class="kt">FiniteDuration</span><span class="o">)</span>
  <span class="o">(</span><span class="k">implicit</span> <span class="n">sc</span><span class="k">:</span> <span class="kt">ScheduledExecutorService</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
 
  <span class="nc">IO</span><span class="o">.</span><span class="n">cancelable</span> <span class="o">{</span> <span class="n">cb</span> <span class="k">=&gt;</span>
    <span class="k">val</span> <span class="n">r</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Runnable</span> <span class="o">{</span> <span class="k">def</span> <span class="n">run</span><span class="o">()</span> <span class="k">=</span> <span class="n">cb</span><span class="o">(</span><span class="nc">Right</span><span class="o">(()))</span> <span class="o">}</span>
    <span class="k">val</span> <span class="n">f</span> <span class="k">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">schedule</span><span class="o">(</span><span class="n">r</span><span class="o">,</span> <span class="n">d</span><span class="o">.</span><span class="n">length</span><span class="o">,</span> <span class="n">d</span><span class="o">.</span><span class="n">unit</span><span class="o">)</span>
    
    <span class="c1">// Returning the cancellation token needed to cancel 
</span>    <span class="c1">// the scheduling and release resources early
</span>    <span class="nc">IO</span><span class="o">(</span><span class="n">f</span><span class="o">.</span><span class="n">cancel</span><span class="o">(</span><span class="kc">false</span><span class="o">)).</span><span class="n">void</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Note this delayed tick is already described by <code class="highlighter-rouge">IO.sleep</code> (via
<code class="highlighter-rouge">Timer</code>), so you don’t need to do it.</p>

<p>More on dealing with ‘‘cancellation’’ below.</p>

<h4 id="ionever">IO.never</h4>

<p><code class="highlighter-rouge">IO.never</code> represents a non-terminating <code class="highlighter-rouge">IO</code> defined in terms of
<code class="highlighter-rouge">async</code>, useful as shortcut and as a reusable reference:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">never</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">.</span><span class="n">async</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="o">())</span>
</code></pre></div></div>

<p>This is useful in order to use non-termination in certain cases, like
race conditions. For example, given <code class="highlighter-rouge">IO.race</code>, we have these
equivalences:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IO</span><span class="o">.</span><span class="n">race</span><span class="o">(</span><span class="n">lh</span><span class="o">,</span> <span class="nc">IO</span><span class="o">.</span><span class="n">never</span><span class="o">)</span> <span class="o">&lt;-&gt;</span> <span class="n">lh</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="nc">Left</span><span class="o">(</span><span class="k">_</span><span class="o">))</span>

<span class="nc">IO</span><span class="o">.</span><span class="n">race</span><span class="o">(</span><span class="nc">IO</span><span class="o">.</span><span class="n">never</span><span class="o">,</span> <span class="n">rh</span><span class="o">)</span> <span class="o">&lt;-&gt;</span> <span class="n">rh</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="nc">Right</span><span class="o">(</span><span class="k">_</span><span class="o">))</span>
</code></pre></div></div>

<h3 id="deferred-execution--iosuspend">Deferred Execution — IO.suspend</h3>

<p>The <code class="highlighter-rouge">IO.suspend</code> builder has this equivalence:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IO</span><span class="o">.</span><span class="n">suspend</span><span class="o">(</span><span class="n">f</span><span class="o">)</span> <span class="o">&lt;-&gt;</span> <span class="nc">IO</span><span class="o">(</span><span class="n">f</span><span class="o">).</span><span class="n">flatten</span>
</code></pre></div></div>

<p>So it is useful for suspending effects, but that defers the completion
of the returned <code class="highlighter-rouge">IO</code> to some other reference. It’s also useful for
modeling stack safe, tail recursive loops:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.IO</span>

<span class="k">def</span> <span class="n">fib</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">Long</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">IO</span><span class="o">.</span><span class="n">suspend</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
      <span class="n">fib</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">)</span>
    <span class="k">else</span>
      <span class="nc">IO</span><span class="o">.</span><span class="n">pure</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>Normally a function like this would eventually yield a stack overflow
error on top of the JVM. By using <code class="highlighter-rouge">IO.suspend</code> and doing all of those
cycles using <code class="highlighter-rouge">IO</code>’s run-loop, its evaluation is lazy and it’s going to
use constant memory. This would work with <code class="highlighter-rouge">flatMap</code> as well, of
course, <code class="highlighter-rouge">suspend</code> being just nicer in this example.</p>

<p>We could describe this function using Scala’s <code class="highlighter-rouge">@tailrec</code> mechanism,
however by using <code class="highlighter-rouge">IO</code> we can also preserve fairness by inserting
asynchronous boundaries:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect._</span>

<span class="k">def</span> <span class="n">fib</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">Long</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">cs</span><span class="k">:</span> <span class="kt">ContextShift</span><span class="o">[</span><span class="kt">IO</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">IO</span><span class="o">.</span><span class="n">suspend</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="nc">IO</span><span class="o">.</span><span class="n">pure</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="k">else</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">next</span> <span class="k">=</span> <span class="n">fib</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">)</span>
      <span class="c1">// Every 100 cycles, introduce a logical thread fork
</span>      <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">100</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
        <span class="n">cs</span><span class="o">.</span><span class="n">shift</span> <span class="o">*&gt;</span> <span class="n">next</span>
      <span class="k">else</span>
        <span class="n">next</span>
    <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>And now we have something more interesting than a <code class="highlighter-rouge">@tailrec</code> loop. As
can be seen, <code class="highlighter-rouge">IO</code> allows very precise control over the evaluation.</p>

<h2 id="concurrency-and-cancellation">Concurrency and Cancellation</h2>

<p><code class="highlighter-rouge">IO</code> can describe interruptible asynchronous processes. As an
implementation detail:</p>

<ol>
  <li>not all <code class="highlighter-rouge">IO</code> tasks are cancelable. Cancellation status is only checked <em>after</em>
asynchronous boundaries. It can be achieved in the following way:
    <ul>
      <li>Building it with <code class="highlighter-rouge">IO.cancelable</code>, <code class="highlighter-rouge">IO.async</code>, <code class="highlighter-rouge">IO.asyncF</code> or <code class="highlighter-rouge">IO.bracket</code></li>
      <li>Using <code class="highlighter-rouge">IO.cancelBoundary</code> or <code class="highlighter-rouge">IO.shift</code></li>
    </ul>
  </li>
</ol>

<p>Note that the second point is the consequence of the first one and anything that involves
  those operations is also possible to cancel. It includes, but is not limited to
  waiting on <code class="highlighter-rouge">Mvar.take</code>, <code class="highlighter-rouge">Mvar.put</code> and <code class="highlighter-rouge">Deferred.get</code>.</p>

<p>We should also note that <code class="highlighter-rouge">flatMap</code> chains are only cancelable only if
  the chain happens <em>after</em> an asynchronous boundary.
  After an asynchronous boundary, cancellation checks are performed on every N <code class="highlighter-rouge">flatMap</code>.
  The value of <code class="highlighter-rouge">N</code> is hardcoded to 512.</p>

<p>Here is an example,</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.</span><span class="o">{</span><span class="nc">ContextShift</span><span class="o">,</span> <span class="nc">IO</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">scala.concurrent.ExecutionContext</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="n">contextShift</span><span class="k">:</span> <span class="kt">ContextShift</span><span class="o">[</span><span class="kt">IO</span><span class="o">]</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">.</span><span class="n">contextShift</span><span class="o">(</span><span class="nc">ExecutionContext</span><span class="o">.</span><span class="n">global</span><span class="o">)</span>

<span class="k">def</span> <span class="n">retryUntilRight</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">io</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="n">io</span><span class="o">.</span><span class="n">flatMap</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Right</span><span class="o">(</span><span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">IO</span><span class="o">.</span><span class="n">pure</span><span class="o">(</span><span class="n">b</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">Left</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">retryUntilRight</span><span class="o">(</span><span class="n">io</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// non-terminating IO that is NOT cancelable
</span><span class="k">val</span> <span class="n">notCancelable</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">retryUntilRight</span><span class="o">(</span><span class="nc">IO</span><span class="o">(</span><span class="nc">Left</span><span class="o">(</span><span class="mi">0</span><span class="o">)))</span>

<span class="c1">// non-terminating IO that is cancelable because there is an
// async boundary created by IO.shift before `flatMap` chain
</span><span class="k">val</span> <span class="n">cancelable</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">.</span><span class="n">shift</span> <span class="o">*&gt;</span> <span class="n">retryUntilRight</span><span class="o">(</span><span class="nc">IO</span><span class="o">(</span><span class="nc">Left</span><span class="o">(</span><span class="mi">0</span><span class="o">)))</span>
</code></pre></div></div>

<ol>
  <li><code class="highlighter-rouge">IO</code> tasks that are cancelable, usually become non-terminating on
<code class="highlighter-rouge">cancel</code></li>
</ol>

<p>Also this might be a point of confusion for folks coming from Java and
that expect the features of <code class="highlighter-rouge">Thread.interrupt</code> or of the old and
deprecated <code class="highlighter-rouge">Thread.stop</code>:</p>

<p><code class="highlighter-rouge">IO</code> cancellation does NOT work like that, as thread interruption in
Java is inherently <em>unsafe, unreliable and not portable</em>!</p>

<p>Next subsections describe cancellation-related operations in more depth.</p>

<h3 id="building-cancelable-io-tasks">Building cancelable IO tasks</h3>

<p>Cancelable <code class="highlighter-rouge">IO</code> tasks can be described via the <code class="highlighter-rouge">IO.cancelable</code>
builder. The <code class="highlighter-rouge">delayedTick</code> example making use of the Java’s
<code class="highlighter-rouge">ScheduledExecutorService</code> was already given above, but to recap:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">java.util.concurrent.ScheduledExecutorService</span>

<span class="k">import</span> <span class="nn">cats.effect.IO</span>

<span class="k">import</span> <span class="nn">scala.concurrent.duration.FiniteDuration</span>

<span class="k">def</span> <span class="n">sleep</span><span class="o">(</span><span class="n">d</span><span class="k">:</span> <span class="kt">FiniteDuration</span><span class="o">)</span>
  <span class="o">(</span><span class="k">implicit</span> <span class="n">sc</span><span class="k">:</span> <span class="kt">ScheduledExecutorService</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>

  <span class="nc">IO</span><span class="o">.</span><span class="n">cancelable</span> <span class="o">{</span> <span class="n">cb</span> <span class="k">=&gt;</span> 
    <span class="k">val</span> <span class="n">r</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Runnable</span> <span class="o">{</span> <span class="k">def</span> <span class="n">run</span><span class="o">()</span> <span class="k">=</span> <span class="n">cb</span><span class="o">(</span><span class="nc">Right</span><span class="o">(()))</span> <span class="o">}</span>
    <span class="k">val</span> <span class="n">f</span> <span class="k">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">schedule</span><span class="o">(</span><span class="n">r</span><span class="o">,</span> <span class="n">d</span><span class="o">.</span><span class="n">length</span><span class="o">,</span> <span class="n">d</span><span class="o">.</span><span class="n">unit</span><span class="o">)</span>
    <span class="c1">// Returning a function that can cancel our scheduling
</span>    <span class="nc">IO</span><span class="o">(</span><span class="n">f</span><span class="o">.</span><span class="n">cancel</span><span class="o">(</span><span class="kc">false</span><span class="o">)).</span><span class="n">void</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Important: if you don’t specify cancellation logic for a task, then the task
is NOT cancelable. So for example, using Java’s blocking I/O still:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">java.io._</span>

<span class="k">import</span> <span class="nn">cats.effect.IO</span>

<span class="k">import</span> <span class="nn">scala.concurrent.ExecutionContext</span>
<span class="k">import</span> <span class="nn">scala.util.control.NonFatal</span>

<span class="k">def</span> <span class="n">unsafeFileToString</span><span class="o">(</span><span class="n">file</span><span class="k">:</span> <span class="kt">File</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
  <span class="c1">// Freaking Java :-)
</span>  <span class="k">val</span> <span class="n">in</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span>
    <span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="n">file</span><span class="o">),</span> <span class="s">"utf-8"</span><span class="o">))</span>
  
  <span class="k">try</span> <span class="o">{</span>
    <span class="c1">// Uninterruptible loop
</span>    <span class="k">val</span> <span class="n">sb</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">()</span>
    <span class="k">var</span> <span class="n">hasNext</span> <span class="k">=</span> <span class="kc">true</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">hasNext</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">hasNext</span> <span class="k">=</span> <span class="kc">false</span>
      <span class="k">val</span> <span class="n">line</span> <span class="k">=</span> <span class="n">in</span><span class="o">.</span><span class="n">readLine</span><span class="o">()</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">line</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">hasNext</span> <span class="k">=</span> <span class="kc">true</span>
        <span class="n">sb</span><span class="o">.</span><span class="n">append</span><span class="o">(</span><span class="n">line</span><span class="o">)</span>
      <span class="o">}</span>
    <span class="o">}</span>
    <span class="n">sb</span><span class="o">.</span><span class="n">toString</span>
  <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
    <span class="n">in</span><span class="o">.</span><span class="n">close</span><span class="o">()</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">def</span> <span class="n">readFile</span><span class="o">(</span><span class="n">file</span><span class="k">:</span> <span class="kt">File</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">ec</span><span class="k">:</span> <span class="kt">ExecutionContext</span><span class="o">)</span> <span class="k">=</span>
  <span class="nc">IO</span><span class="o">.</span><span class="n">async</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="o">{</span> <span class="n">cb</span> <span class="k">=&gt;</span>
    <span class="n">ec</span><span class="o">.</span><span class="n">execute</span><span class="o">(()</span> <span class="k">=&gt;</span> <span class="o">{</span>
      <span class="k">try</span> <span class="o">{</span>
        <span class="c1">// Signal completion
</span>        <span class="n">cb</span><span class="o">(</span><span class="nc">Right</span><span class="o">(</span><span class="n">unsafeFileToString</span><span class="o">(</span><span class="n">file</span><span class="o">)))</span>
      <span class="o">}</span> <span class="k">catch</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">NonFatal</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="k">=&gt;</span>
          <span class="n">cb</span><span class="o">(</span><span class="nc">Left</span><span class="o">(</span><span class="n">e</span><span class="o">))</span>
      <span class="o">}</span>
    <span class="o">})</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>This is obviously not cancelable and there’s no magic that the <code class="highlighter-rouge">IO</code>
implementation does to make that loop cancelable. No, we are not going
to use Java’s <code class="highlighter-rouge">Thread.interrupt</code>, because that would be unsafe and
unreliable and besides, whatever the <code class="highlighter-rouge">IO</code> does has to be portable
between platforms.</p>

<p>But there’s a lot of flexibility in what can be done, including here.
We could simply introduce a variable that changes to <code class="highlighter-rouge">false</code>, to be
observed in that <code class="highlighter-rouge">while</code> loop:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">java.io.File</span>
<span class="k">import</span> <span class="nn">java.util.concurrent.atomic.AtomicBoolean</span>

<span class="k">import</span> <span class="nn">cats.effect.IO</span>

<span class="k">import</span> <span class="nn">scala.concurrent.ExecutionContext</span>
<span class="k">import</span> <span class="nn">scala.io.Source</span>
<span class="k">import</span> <span class="nn">scala.util.control.NonFatal</span>

<span class="k">def</span> <span class="n">unsafeFileToString</span><span class="o">(</span><span class="n">file</span><span class="k">:</span> <span class="kt">File</span><span class="o">,</span> <span class="n">isActive</span><span class="k">:</span> <span class="kt">AtomicBoolean</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">sc</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span>
  <span class="k">val</span> <span class="n">linesIterator</span> <span class="k">=</span> <span class="nc">Source</span><span class="o">.</span><span class="n">fromFile</span><span class="o">(</span><span class="n">file</span><span class="o">).</span><span class="n">getLines</span><span class="o">()</span>
  <span class="k">var</span> <span class="n">hasNext</span> <span class="k">=</span> <span class="kc">true</span>
  <span class="k">while</span> <span class="o">(</span><span class="n">hasNext</span> <span class="o">&amp;&amp;</span> <span class="n">isActive</span><span class="o">.</span><span class="n">get</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">sc</span><span class="o">.</span><span class="n">append</span><span class="o">(</span><span class="n">linesIterator</span><span class="o">.</span><span class="n">next</span><span class="o">())</span>
    <span class="n">hasNext</span> <span class="k">=</span> <span class="n">linesIterator</span><span class="o">.</span><span class="n">hasNext</span>
  <span class="o">}</span>
  <span class="n">sc</span><span class="o">.</span><span class="n">toString</span>
<span class="o">}</span>

<span class="k">def</span> <span class="n">readFile</span><span class="o">(</span><span class="n">file</span><span class="k">:</span> <span class="kt">File</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">ec</span><span class="k">:</span> <span class="kt">ExecutionContext</span><span class="o">)</span> <span class="k">=</span>
  <span class="nc">IO</span><span class="o">.</span><span class="n">cancelable</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="o">{</span> <span class="n">cb</span> <span class="k">=&gt;</span>
    <span class="k">val</span> <span class="n">isActive</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">AtomicBoolean</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span>
    
    <span class="n">ec</span><span class="o">.</span><span class="n">execute</span><span class="o">(()</span> <span class="k">=&gt;</span> <span class="o">{</span>
      <span class="k">try</span> <span class="o">{</span>
        <span class="c1">// Signal completion
</span>        <span class="n">cb</span><span class="o">(</span><span class="nc">Right</span><span class="o">(</span><span class="n">unsafeFileToString</span><span class="o">(</span><span class="n">file</span><span class="o">,</span> <span class="n">isActive</span><span class="o">)))</span>
      <span class="o">}</span> <span class="k">catch</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">NonFatal</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="k">=&gt;</span>
          <span class="n">cb</span><span class="o">(</span><span class="nc">Left</span><span class="o">(</span><span class="n">e</span><span class="o">))</span>
      <span class="o">}</span>
    <span class="o">})</span>    
    <span class="c1">// On cancel, signal it
</span>    <span class="nc">IO</span><span class="o">(</span><span class="n">isActive</span><span class="o">.</span><span class="n">set</span><span class="o">(</span><span class="kc">false</span><span class="o">)).</span><span class="n">void</span>
  <span class="o">}</span>
</code></pre></div></div>

<h4 id="gotcha-cancellation-is-a-concurrent-action">Gotcha: Cancellation is a Concurrent Action!</h4>

<p>This is not always obvious, not from the above examples, but you might
be tempted to do something like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">java.io._</span>

<span class="k">import</span> <span class="nn">cats.effect.IO</span>

<span class="k">import</span> <span class="nn">scala.concurrent.ExecutionContext</span>
<span class="k">import</span> <span class="nn">scala.util.control.NonFatal</span>

<span class="k">def</span> <span class="n">readLine</span><span class="o">(</span><span class="n">in</span><span class="k">:</span> <span class="kt">BufferedReader</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">ec</span><span class="k">:</span> <span class="kt">ExecutionContext</span><span class="o">)</span> <span class="k">=</span>
  <span class="nc">IO</span><span class="o">.</span><span class="n">cancelable</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="o">{</span> <span class="n">cb</span> <span class="k">=&gt;</span>
    <span class="n">ec</span><span class="o">.</span><span class="n">execute</span><span class="o">(()</span> <span class="k">=&gt;</span> <span class="n">cb</span><span class="o">(</span>
      <span class="k">try</span> <span class="nc">Right</span><span class="o">(</span><span class="n">in</span><span class="o">.</span><span class="n">readLine</span><span class="o">())</span> 
      <span class="k">catch</span> <span class="o">{</span> <span class="k">case</span> <span class="nc">NonFatal</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Left</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="o">}))</span>
      
    <span class="c1">// Cancellation logic is not thread-safe!
</span>    <span class="nc">IO</span><span class="o">(</span><span class="n">in</span><span class="o">.</span><span class="n">close</span><span class="o">()).</span><span class="n">void</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>An operation like this might be useful in streaming abstractions that
stream I/O chunks via <code class="highlighter-rouge">IO</code> (via libraries like FS2, Monix, or others).</p>

<p>But the described operation is incorrect, because <code class="highlighter-rouge">in.close()</code> is
<em>concurrent</em> with <code class="highlighter-rouge">in.readLine</code>, which can lead to thrown exceptions
and in many cases it can lead to data <em>corruption</em>. This is a big
no-no. We want to interrupt whatever it is that the <code class="highlighter-rouge">IO</code> is doing, but
not at the cost of data corruption.</p>

<p>Therefore the user needs to handle thread safety concerns. So here’s
one way of doing it:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">java.io._</span>
<span class="k">import</span> <span class="nn">java.util.concurrent.atomic.AtomicBoolean</span>

<span class="k">import</span> <span class="nn">cats.effect.IO</span>

<span class="k">import</span> <span class="nn">scala.util.control.NonFatal</span>
<span class="k">import</span> <span class="nn">scala.concurrent.ExecutionContext</span>

<span class="k">def</span> <span class="n">readLine</span><span class="o">(</span><span class="n">in</span><span class="k">:</span> <span class="kt">BufferedReader</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">ec</span><span class="k">:</span> <span class="kt">ExecutionContext</span><span class="o">)</span> <span class="k">=</span>
  <span class="nc">IO</span><span class="o">.</span><span class="n">cancelable</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="o">{</span> <span class="n">cb</span> <span class="k">=&gt;</span>
    <span class="k">val</span> <span class="n">isActive</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">AtomicBoolean</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span>
    <span class="n">ec</span><span class="o">.</span><span class="n">execute</span> <span class="o">{</span> <span class="o">()</span> <span class="k">=&gt;</span> 
      <span class="k">if</span> <span class="o">(</span><span class="n">isActive</span><span class="o">.</span><span class="n">getAndSet</span><span class="o">(</span><span class="kc">false</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">try</span> <span class="n">cb</span><span class="o">(</span><span class="nc">Right</span><span class="o">(</span><span class="n">in</span><span class="o">.</span><span class="n">readLine</span><span class="o">()))</span>
        <span class="k">catch</span> <span class="o">{</span> <span class="k">case</span> <span class="nc">NonFatal</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">cb</span><span class="o">(</span><span class="nc">Left</span><span class="o">(</span><span class="n">e</span><span class="o">))</span> <span class="o">}</span>
      <span class="o">}</span>
      <span class="c1">// Note there's no else; if cancellation was executed
</span>      <span class="c1">// then we don't call the callback; task becoming 
</span>      <span class="c1">// non-terminating ;-)
</span>    <span class="o">}</span>
    <span class="c1">// Cancellation logic
</span>    <span class="nc">IO</span> <span class="o">{</span>
      <span class="c1">// Thread-safe gate
</span>      <span class="k">if</span> <span class="o">(</span><span class="n">isActive</span><span class="o">.</span><span class="n">getAndSet</span><span class="o">(</span><span class="kc">false</span><span class="o">))</span>
        <span class="n">in</span><span class="o">.</span><span class="n">close</span><span class="o">()</span>
    <span class="o">}.</span><span class="n">void</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>In this example it is the cancellation logic itself that calls
<code class="highlighter-rouge">in.close()</code>, but the call is safe due to the thread-safe guard that
we’re creating by usage of an atomic <code class="highlighter-rouge">getAndSet</code>.</p>

<p>This is using an <code class="highlighter-rouge">AtomicBoolean</code> for thread-safety, but don’t shy away
from using intrinsic locks / mutexes via <code class="highlighter-rouge">synchronize</code> blocks or
whatever else concurrency primitives the JVM provides, whatever is
needed in these side effectful functions. And don’t worry, this is
usually needed only in <code class="highlighter-rouge">IO.cancelable</code>, <code class="highlighter-rouge">IO.async</code> or <code class="highlighter-rouge">IO.apply</code>, as
these builders represents the FFI for interacting with the impure
world, aka the dark side, otherwise once you’re in <code class="highlighter-rouge">IO</code>’s context, you
can compose concurrent tasks using higher level tools.</p>

<p>Shared memory concurrency is unfortunately both the blessing and the
curse of working with kernel threads. Not a big problem on N:1
platforms like JavaScript, but there you don’t get in-process CPU
parallelism either. Such is life, a big trail of tradeoffs.</p>

<h3 id="concurrent-start--cancel">Concurrent start + cancel</h3>

<p>You can use <code class="highlighter-rouge">IO</code> as a green-threads system, with the “fork” operation
being available via <code class="highlighter-rouge">IO#start</code>, the operation that’s compliant with
<code class="highlighter-rouge">Concurrent#start</code>. This is a method with the following signature:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">start</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Fiber</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">A</span><span class="o">]]</span>
</code></pre></div></div>

<p>Returned is a <a href="/cats-effect/datatypes/fiber.html">Fiber</a>. You can think of fibers as being
lightweight threads, a fiber being the pure and light equivalent of a
thread that can be either joined (via <code class="highlighter-rouge">join</code>) or interrupted (via
<code class="highlighter-rouge">cancel</code>).</p>

<p>Example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.</span><span class="o">{</span><span class="nc">ContextShift</span><span class="o">,</span> <span class="nc">IO</span><span class="o">}</span>

<span class="k">import</span> <span class="nn">scala.concurrent.ExecutionContext</span>

<span class="c1">// Needed for IO.start to do a logical thread fork
</span><span class="k">implicit</span> <span class="k">val</span> <span class="n">cs</span><span class="k">:</span> <span class="kt">ContextShift</span><span class="o">[</span><span class="kt">IO</span><span class="o">]</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">.</span><span class="n">contextShift</span><span class="o">(</span><span class="nc">ExecutionContext</span><span class="o">.</span><span class="n">global</span><span class="o">)</span>

<span class="k">val</span> <span class="n">launchMissiles</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">.</span><span class="n">raiseError</span><span class="o">(</span><span class="k">new</span> <span class="nc">Exception</span><span class="o">(</span><span class="s">"boom!"</span><span class="o">))</span>
<span class="k">val</span> <span class="n">runToBunker</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="s">"To the bunker!!!"</span><span class="o">))</span>

<span class="k">for</span> <span class="o">{</span>
  <span class="n">fiber</span> <span class="k">&lt;-</span> <span class="n">launchMissiles</span><span class="o">.</span><span class="n">start</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">runToBunker</span><span class="o">.</span><span class="n">handleErrorWith</span> <span class="o">{</span> <span class="n">error</span> <span class="k">=&gt;</span>
    <span class="c1">// Retreat failed, cancel launch (maybe we should
</span>    <span class="c1">// have retreated to our bunker before the launch?)
</span>    <span class="n">fiber</span><span class="o">.</span><span class="n">cancel</span> <span class="o">*&gt;</span> <span class="nc">IO</span><span class="o">.</span><span class="n">raiseError</span><span class="o">(</span><span class="n">error</span><span class="o">)</span>
  <span class="o">}</span>
  <span class="n">aftermath</span> <span class="k">&lt;-</span> <span class="n">fiber</span><span class="o">.</span><span class="n">join</span>
<span class="o">}</span> <span class="k">yield</span> <span class="n">aftermath</span>
</code></pre></div></div>

<p>Implementation notes:</p>

<ul>
  <li>the <code class="highlighter-rouge">*&gt;</code> operator is defined in Cats and you can treat it as an
alias for <code class="highlighter-rouge">lh.flatMap(_ =&gt; rh)</code></li>
</ul>

<h3 id="runcancelable--unsaferuncancelable">runCancelable &amp; unsafeRunCancelable</h3>

<p>The above is the pure <code class="highlighter-rouge">cancel</code>, accessible via <code class="highlighter-rouge">Fiber</code>. However the
second way to access cancellation token and thus interrupt tasks is via
<code class="highlighter-rouge">runCancelable</code> (the pure version) and <code class="highlighter-rouge">unsafeRunCancelable</code> (the
unsafe version).</p>

<p>Example relying on the side-effecting <code class="highlighter-rouge">unsafeRunCancelable</code> and note
this kind of code is impure and should be used with care:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.IO</span>

<span class="k">import</span> <span class="nn">scala.concurrent.ExecutionContext</span>
<span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="c1">// Needed for `sleep`
</span><span class="k">implicit</span> <span class="k">val</span> <span class="n">timer</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">.</span><span class="n">timer</span><span class="o">(</span><span class="nc">ExecutionContext</span><span class="o">.</span><span class="n">global</span><span class="o">)</span>

<span class="c1">// Delayed println
</span><span class="k">val</span> <span class="n">io</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">.</span><span class="n">sleep</span><span class="o">(</span><span class="mf">10.</span><span class="n">seconds</span><span class="o">)</span> <span class="o">*&gt;</span> <span class="nc">IO</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="s">"Hello!"</span><span class="o">))</span>

<span class="k">val</span> <span class="n">cancel</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> 
  <span class="n">io</span><span class="o">.</span><span class="n">unsafeRunCancelable</span><span class="o">(</span><span class="n">r</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Done: $r"</span><span class="o">))</span>

<span class="c1">// ... if a race condition happens, we can cancel it,
// thus canceling the scheduling of `IO.sleep`
</span><span class="n">cancel</span><span class="o">.</span><span class="n">unsafeRunSync</span><span class="o">()</span>
</code></pre></div></div>

<p>The <code class="highlighter-rouge">runCancelable</code> alternative is the operation that’s compliant with
the laws of <a href="/cats-effect/typeclasses/concurrent-effect.html">ConcurrentEffect</a>.
Same idea, only the actual execution is suspended in <code class="highlighter-rouge">SyncIO</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.SyncIO</span>
<span class="k">import</span> <span class="nn">cats.syntax.flatMap._</span>

<span class="k">val</span> <span class="n">pureResult</span><span class="k">:</span> <span class="kt">SyncIO</span><span class="o">[</span><span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]]</span> <span class="k">=</span> <span class="n">io</span><span class="o">.</span><span class="n">runCancelable</span> <span class="o">{</span> <span class="n">r</span> <span class="k">=&gt;</span> 
  <span class="nc">IO</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Done: $r"</span><span class="o">))</span>
<span class="o">}</span>

<span class="c1">// On evaluation, this will first execute the source, then it 
// will cancel it, because it makes perfect sense :-)
</span><span class="n">pureResult</span><span class="o">.</span><span class="n">toIO</span><span class="o">.</span><span class="n">flatten</span>
</code></pre></div></div>

<h3 id="uncancelable-marker">uncancelable marker</h3>

<p>Given a cancelable <code class="highlighter-rouge">IO</code>, we can turn it into an <code class="highlighter-rouge">IO</code> that cannot be
canceled:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.IO</span>

<span class="k">import</span> <span class="nn">scala.concurrent.ExecutionContext</span>
<span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="c1">// Needed for `sleep`
</span><span class="k">implicit</span> <span class="k">val</span> <span class="n">timer</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">.</span><span class="n">timer</span><span class="o">(</span><span class="nc">ExecutionContext</span><span class="o">.</span><span class="n">global</span><span class="o">)</span>

<span class="c1">// Our reference from above
</span><span class="k">val</span> <span class="n">io</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">.</span><span class="n">sleep</span><span class="o">(</span><span class="mf">10.</span><span class="n">seconds</span><span class="o">)</span> <span class="o">*&gt;</span> <span class="nc">IO</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="s">"Hello!"</span><span class="o">))</span>

<span class="c1">// This IO can't be canceled, even if we try
</span><span class="n">io</span><span class="o">.</span><span class="n">uncancelable</span>
</code></pre></div></div>

<p>Sometimes you need to ensure that an <code class="highlighter-rouge">IO</code>’s execution is <em>atomic</em>, or
in other words, either all of it executes, or none of it. And this is
what this operation does — cancelable IOs are by definition not atomic
and in certain cases we need to make them atomic.</p>

<p>This law is compliant with the laws of <code class="highlighter-rouge">Concurrent#uncancelable</code> (see
<a href="/cats-effect/typeclasses/concurrent.html">Concurrent</a>).</p>

<h3 id="iocancelboundary">IO.cancelBoundary</h3>

<p>Returns a cancelable boundary — an <code class="highlighter-rouge">IO</code> task that checks for the
cancellation status of the run-loop and does not allow for the bind
continuation to keep executing in case cancellation happened.</p>

<p>This operation is very similar to <code class="highlighter-rouge">IO.shift</code>, as it can be dropped in
<code class="highlighter-rouge">flatMap</code> chains in order to make such long loops cancelable:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.IO</span>

<span class="k">def</span> <span class="n">fib</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">Long</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">IO</span><span class="o">.</span><span class="n">suspend</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="nc">IO</span><span class="o">.</span><span class="n">pure</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="k">else</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">next</span> <span class="k">=</span> <span class="n">fib</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">)</span>

      <span class="c1">// Every 100-th cycle check cancellation status
</span>      <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">100</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
        <span class="nc">IO</span><span class="o">.</span><span class="n">cancelBoundary</span> <span class="o">*&gt;</span> <span class="n">next</span>
      <span class="k">else</span>
        <span class="n">next</span>
    <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>As mentioned at the very beginning of this section, fairness needs to be managed explicitly, 
the protocol being easy to follow and predictable in a WYSIWYG fashion.</p>

<h4 id="comparison-to-ioshift">Comparison to IO.shift</h4>

<p><code class="highlighter-rouge">IO.cancelBoundary</code> is essentially lighter version of <code class="highlighter-rouge">IO.shift</code> without 
ability to shift into different thread pool. It is lighter in the sense that
it will avoid doing logical fork.</p>

<h3 id="race-conditions--race--racepair">Race Conditions — race &amp; racePair</h3>

<p>A race condition is a piece of logic that creates a race between two
or more tasks, with the winner being signaled immediately, with the
losers being usually canceled.</p>

<p><code class="highlighter-rouge">IO</code> provides two operations for races in its companion:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// simple version
</span><span class="k">def</span> <span class="n">race</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">lh</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">rh</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span>
  <span class="o">(</span><span class="k">implicit</span> <span class="n">cs</span><span class="k">:</span> <span class="kt">ContextShift</span><span class="o">[</span><span class="kt">IO</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]]</span>
  
<span class="c1">// advanced version
</span><span class="k">def</span> <span class="n">racePair</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">lh</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">rh</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span>
  <span class="o">(</span><span class="k">implicit</span> <span class="n">cs</span><span class="k">:</span> <span class="kt">ContextShift</span><span class="o">[</span><span class="kt">IO</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Either</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">Fiber</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">B</span><span class="o">])</span>, <span class="o">(</span><span class="kt">Fiber</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">A</span><span class="o">]</span>, <span class="kt">B</span><span class="o">)]]</span>
</code></pre></div></div>

<p>The simple version, <code class="highlighter-rouge">IO.race</code>, will cancel the loser immediately,
whereas the second version gives you a <a href="/cats-effect/datatypes/fiber.html">Fiber</a>, letting
you decide what to do next.</p>

<p>So <code class="highlighter-rouge">race</code> can be derived with <code class="highlighter-rouge">racePair</code> like so:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.</span><span class="o">{</span><span class="nc">ContextShift</span><span class="o">,</span> <span class="nc">IO</span><span class="o">}</span>

<span class="k">def</span> <span class="n">race</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">lh</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">rh</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span>
  <span class="o">(</span><span class="k">implicit</span> <span class="n">cs</span><span class="k">:</span> <span class="kt">ContextShift</span><span class="o">[</span><span class="kt">IO</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]]</span> <span class="k">=</span> <span class="o">{</span>
  
  <span class="nc">IO</span><span class="o">.</span><span class="n">racePair</span><span class="o">(</span><span class="n">lh</span><span class="o">,</span> <span class="n">rh</span><span class="o">).</span><span class="n">flatMap</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Left</span><span class="o">((</span><span class="n">a</span><span class="o">,</span> <span class="n">fiber</span><span class="o">))</span> <span class="k">=&gt;</span> 
      <span class="n">fiber</span><span class="o">.</span><span class="n">cancel</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">Left</span><span class="o">(</span><span class="n">a</span><span class="o">))</span>
    <span class="k">case</span> <span class="nc">Right</span><span class="o">((</span><span class="n">fiber</span><span class="o">,</span> <span class="n">b</span><span class="o">))</span> <span class="k">=&gt;</span> 
      <span class="n">fiber</span><span class="o">.</span><span class="n">cancel</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">Right</span><span class="o">(</span><span class="n">b</span><span class="o">))</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Using <code class="highlighter-rouge">race</code> we could implement a “timeout” operation:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.</span><span class="o">{</span><span class="nc">ContextShift</span><span class="o">,</span> <span class="nc">Timer</span><span class="o">,</span> <span class="nc">IO</span><span class="o">}</span>

<span class="k">import</span> <span class="nn">scala.concurrent.CancellationException</span>
<span class="k">import</span> <span class="nn">scala.concurrent.duration.FiniteDuration</span>

<span class="k">def</span> <span class="n">timeoutTo</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">after</span><span class="k">:</span> <span class="kt">FiniteDuration</span><span class="o">,</span> <span class="n">fallback</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span>
  <span class="o">(</span><span class="k">implicit</span> <span class="n">timer</span><span class="k">:</span> <span class="kt">Timer</span><span class="o">[</span><span class="kt">IO</span><span class="o">],</span> <span class="n">cs</span><span class="k">:</span> <span class="kt">ContextShift</span><span class="o">[</span><span class="kt">IO</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>

  <span class="nc">IO</span><span class="o">.</span><span class="n">race</span><span class="o">(</span><span class="n">fa</span><span class="o">,</span> <span class="n">timer</span><span class="o">.</span><span class="n">sleep</span><span class="o">(</span><span class="n">after</span><span class="o">)).</span><span class="n">flatMap</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Left</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">IO</span><span class="o">.</span><span class="n">pure</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">Right</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">fallback</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">def</span> <span class="n">timeout</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">after</span><span class="k">:</span> <span class="kt">FiniteDuration</span><span class="o">)</span>
  <span class="o">(</span><span class="k">implicit</span> <span class="n">timer</span><span class="k">:</span> <span class="kt">Timer</span><span class="o">[</span><span class="kt">IO</span><span class="o">],</span> <span class="n">cs</span><span class="k">:</span> <span class="kt">ContextShift</span><span class="o">[</span><span class="kt">IO</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>

  <span class="k">val</span> <span class="n">error</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">CancellationException</span><span class="o">(</span><span class="n">after</span><span class="o">.</span><span class="n">toString</span><span class="o">)</span>
  <span class="n">timeoutTo</span><span class="o">(</span><span class="n">fa</span><span class="o">,</span> <span class="n">after</span><span class="o">,</span> <span class="nc">IO</span><span class="o">.</span><span class="n">raiseError</span><span class="o">(</span><span class="n">error</span><span class="o">))</span>
<span class="o">}</span>
</code></pre></div></div>

<p>See <em>Parallelism</em> section above for how to obtain a <code class="highlighter-rouge">Timer[IO]</code></p>

<h3 id="comparison-with-haskells-async-interruption">Comparison with Haskell’s “async interruption”</h3>

<p>Haskell treats interruption with what they call “asynchronous
exceptions”, providing the ability to interrupt a running task by 
throwing an exception from another thread (concurrently).</p>

<p>For <code class="highlighter-rouge">cats.effect</code>, for the “cancel” action, what happens is that
whatever you specify in the <code class="highlighter-rouge">IO.cancelable</code> builder gets executed. And
depending on the implementation of an <code class="highlighter-rouge">IO.cancelable</code> task, it can
become non-terminating. If we’d need to describe our <code class="highlighter-rouge">cancel</code>
operation with an impure signature, it would be:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">()</span> <span class="k">=&gt;</span> <span class="nc">Unit</span>
</code></pre></div></div>

<p>By comparison Haskell (and possibly the upcoming Scalaz 8 <code class="highlighter-rouge">IO</code>), sends
an error, a <code class="highlighter-rouge">Throwable</code> on interruption and canceled tasks get
completed with that <code class="highlighter-rouge">Throwable</code>. Their impure cancel is:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Throwable</span> <span class="k">=&gt;</span> <span class="nc">Unit</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">Throwable =&gt; Unit</code> allows the task’s logic to know the cancellation
reason, however cancellation is about cutting the connection to the
producer, closing all resources as soon as possible, because you’re no
longer interested in the result, due to some race condition that
happened.</p>

<p><code class="highlighter-rouge">Throwable =&gt; Unit</code> is also a little confusing, being too broad in
scope. Users might be tricked into sending messages back to the
producer via this channel, in order to steer it, to change its
outcome - however cancellation is cancellation, we’re doing it for the
purpose of releasing resources and the implementation of race
conditions will end up closing the connection, disallowing the
canceled task to send anything downstream.</p>

<p>Therefore it’s confusing for the user and the only practical use is to
release resources differently, based on the received error. But that’s
not a use-case that’s worth pursuing, given the increase in
complexity.</p>

<h2 id="safe-resource-acquisition-and-release">Safe Resource Acquisition and Release</h2>

<h3 id="status-quo">Status Quo</h3>

<p>In mainstream imperative languages you usually have <code class="highlighter-rouge">try / finally</code>
statements at disposal for acquisition and safe release of resources.
Pattern goes like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">java.io._</span>

<span class="k">def</span> <span class="n">javaReadFirstLine</span><span class="o">(</span><span class="n">file</span><span class="k">:</span> <span class="kt">File</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">in</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="n">file</span><span class="o">))</span>
  <span class="k">try</span> <span class="o">{</span>
    <span class="n">in</span><span class="o">.</span><span class="n">readLine</span><span class="o">()</span>
  <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
    <span class="n">in</span><span class="o">.</span><span class="n">close</span><span class="o">()</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>It does have problems like:</p>

<ol>
  <li>this statement is obviously meant for side-effectful computations
and can’t be used by FP abstractions</li>
  <li>it’s only meant for synchronous execution, so we can’t use it
when working with abstractions capable of asynchrony
(e.g. <code class="highlighter-rouge">IO</code>, <code class="highlighter-rouge">Task</code>, <code class="highlighter-rouge">Future</code>)</li>
  <li><code class="highlighter-rouge">finally</code> executes regardless of the exception type,
indiscriminately, so if you get an out of memory error it still
tries to close the file handle, unnecessarily delaying a process
crash</li>
  <li>if the body of <code class="highlighter-rouge">try</code> throws an exception, then followed by
the body of <code class="highlighter-rouge">finally</code> also throwing an exception, then the
exception of <code class="highlighter-rouge">finally</code> gets rethrown, hiding the original problem</li>
</ol>

<h3 id="bracket">bracket</h3>

<p>Via the <code class="highlighter-rouge">bracket</code> operation we can easily describe the above:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">java.io._</span>

<span class="k">import</span> <span class="nn">cats.effect.IO</span>

<span class="k">def</span> <span class="n">readFirstLine</span><span class="o">(</span><span class="n">file</span><span class="k">:</span> <span class="kt">File</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">IO</span><span class="o">(</span><span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="n">file</span><span class="o">))).</span><span class="n">bracket</span> <span class="o">{</span> <span class="n">in</span> <span class="k">=&gt;</span>
    <span class="c1">// Usage (the try block)
</span>    <span class="nc">IO</span><span class="o">(</span><span class="n">in</span><span class="o">.</span><span class="n">readLine</span><span class="o">())</span>
  <span class="o">}</span> <span class="o">{</span> <span class="n">in</span> <span class="k">=&gt;</span>
    <span class="c1">// Releasing the reader (the finally block)
</span>    <span class="nc">IO</span><span class="o">(</span><span class="n">in</span><span class="o">.</span><span class="n">close</span><span class="o">()).</span><span class="n">void</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>Notes:</p>

<ol>
  <li>this is pure, so it can be used for FP</li>
  <li>this works with asynchronous <code class="highlighter-rouge">IO</code> actions</li>
  <li>the <code class="highlighter-rouge">release</code> action will happen regardless of the exit status 
of the <code class="highlighter-rouge">use</code> action, so it will execute for successful completion,
for thrown errors or for canceled execution</li>
  <li>if the <code class="highlighter-rouge">use</code> action throws an error and then the <code class="highlighter-rouge">release</code> action
throws an error as well, the reported error will be that of
<code class="highlighter-rouge">use</code>, whereas the error thrown by <code class="highlighter-rouge">release</code> will just get logged
(via <code class="highlighter-rouge">System.err</code>)</li>
</ol>

<p>Of special consideration is that <code class="highlighter-rouge">bracket</code> calls the <code class="highlighter-rouge">release</code> action
on cancellation as well. Consider this sample:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">java.io._</span>

<span class="k">import</span> <span class="nn">cats.effect.</span><span class="o">{</span><span class="nc">ContextShift</span><span class="o">,</span> <span class="nc">IO</span><span class="o">}</span>

<span class="k">import</span> <span class="nn">scala.concurrent.ExecutionContext</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="n">contextShift</span><span class="k">:</span> <span class="kt">ContextShift</span><span class="o">[</span><span class="kt">IO</span><span class="o">]</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">.</span><span class="n">contextShift</span><span class="o">(</span><span class="nc">ExecutionContext</span><span class="o">.</span><span class="n">global</span><span class="o">)</span>

<span class="k">def</span> <span class="n">readFile</span><span class="o">(</span><span class="n">file</span><span class="k">:</span> <span class="kt">File</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="c1">// Opens file with an asynchronous boundary before it, 
</span>  <span class="c1">// ensuring that processing doesn't block the "current thread"
</span>  <span class="k">val</span> <span class="n">acquire</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">.</span><span class="n">shift</span> <span class="o">*&gt;</span> <span class="nc">IO</span><span class="o">(</span><span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="n">file</span><span class="o">)))</span>
    
  <span class="n">acquire</span><span class="o">.</span><span class="n">bracket</span> <span class="o">{</span> <span class="n">in</span> <span class="k">=&gt;</span>
    <span class="c1">// Usage (the try block)
</span>    <span class="nc">IO</span> <span class="o">{</span>
      <span class="c1">// Ugly, low-level Java code warning!
</span>      <span class="k">val</span> <span class="n">content</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">()</span>
      <span class="k">var</span> <span class="n">line</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="kc">null</span>
      <span class="k">do</span> <span class="o">{</span>
        <span class="n">line</span> <span class="k">=</span> <span class="n">in</span><span class="o">.</span><span class="n">readLine</span><span class="o">()</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">line</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">content</span><span class="o">.</span><span class="n">append</span><span class="o">(</span><span class="n">line</span><span class="o">)</span>
      <span class="o">}</span> <span class="k">while</span> <span class="o">(</span><span class="n">line</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
      <span class="n">content</span><span class="o">.</span><span class="n">toString</span><span class="o">()</span>
    <span class="o">}</span>
  <span class="o">}</span> <span class="o">{</span> <span class="n">in</span> <span class="k">=&gt;</span>
    <span class="c1">// Releasing the reader (the finally block)
</span>    <span class="c1">// This is problematic if the resulting `IO` can get 
</span>    <span class="c1">// canceled, because it can lead to data corruption
</span>    <span class="nc">IO</span><span class="o">(</span><span class="n">in</span><span class="o">.</span><span class="n">close</span><span class="o">()).</span><span class="n">void</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>That loop can be slow, we could be talking about a big file and
as described in the “<em>Concurrency and Cancellation</em>” section,
cancellation is a concurrent action with whatever goes on in <code class="highlighter-rouge">use</code>.</p>

<p>And in this case, on top of the JVM that is capable of multi-threading, 
calling <code class="highlighter-rouge">io.close()</code> concurrently with that loop
can lead to data corruption. Depending on use-case synchronization
might be needed to prevent it:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">java.io._</span>

<span class="k">import</span> <span class="nn">cats.effect.</span><span class="o">{</span><span class="nc">ContextShift</span><span class="o">,</span> <span class="nc">IO</span><span class="o">}</span>

<span class="k">import</span> <span class="nn">scala.concurrent.ExecutionContext</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="n">contextShift</span><span class="k">:</span> <span class="kt">ContextShift</span><span class="o">[</span><span class="kt">IO</span><span class="o">]</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">.</span><span class="n">contextShift</span><span class="o">(</span><span class="nc">ExecutionContext</span><span class="o">.</span><span class="n">global</span><span class="o">)</span>

<span class="k">def</span> <span class="n">readFile</span><span class="o">(</span><span class="n">file</span><span class="k">:</span> <span class="kt">File</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="c1">// Opens file with an asynchronous boundary before it, 
</span>  <span class="c1">// ensuring that processing doesn't block the "current thread"
</span>  <span class="k">val</span> <span class="n">acquire</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">.</span><span class="n">shift</span> <span class="o">*&gt;</span> <span class="nc">IO</span><span class="o">(</span><span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="n">file</span><span class="o">)))</span>
    
  <span class="c1">// Suspended execution because we are going to mutate 
</span>  <span class="c1">// a shared variable
</span>  <span class="nc">IO</span><span class="o">.</span><span class="n">suspend</span> <span class="o">{</span>
    <span class="c1">// Shared state meant to signal cancellation
</span>    <span class="k">var</span> <span class="n">isCanceled</span> <span class="k">=</span> <span class="kc">false</span>
    
    <span class="n">acquire</span><span class="o">.</span><span class="n">bracket</span> <span class="o">{</span> <span class="n">in</span> <span class="k">=&gt;</span>
      <span class="nc">IO</span> <span class="o">{</span>
        <span class="k">val</span> <span class="n">content</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">()</span>
        <span class="k">var</span> <span class="n">line</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="kc">null</span>
        <span class="k">do</span> <span class="o">{</span>
        <span class="c1">// Synchronized access to isCanceled and to the reader
</span>          <span class="n">line</span> <span class="k">=</span> <span class="n">in</span><span class="o">.</span><span class="n">synchronized</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">isCanceled</span><span class="o">)</span>
              <span class="n">in</span><span class="o">.</span><span class="n">readLine</span><span class="o">()</span>
            <span class="k">else</span>
              <span class="kc">null</span>
          <span class="o">}</span>
          <span class="k">if</span> <span class="o">(</span><span class="n">line</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">content</span><span class="o">.</span><span class="n">append</span><span class="o">(</span><span class="n">line</span><span class="o">)</span>
        <span class="o">}</span> <span class="k">while</span> <span class="o">(</span><span class="n">line</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
        <span class="n">content</span><span class="o">.</span><span class="n">toString</span><span class="o">()</span>
      <span class="o">}</span>
    <span class="o">}</span> <span class="o">{</span> <span class="n">in</span> <span class="k">=&gt;</span>
      <span class="nc">IO</span> <span class="o">{</span>
        <span class="c1">// Synchronized access to isCanceled and to the reader
</span>        <span class="n">in</span><span class="o">.</span><span class="n">synchronized</span> <span class="o">{</span>
          <span class="n">isCanceled</span> <span class="k">=</span> <span class="kc">true</span>
          <span class="n">in</span><span class="o">.</span><span class="n">close</span><span class="o">()</span>
        <span class="o">}</span>
      <span class="o">}.</span><span class="n">void</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="bracketcase">bracketCase</h3>

<p>The <code class="highlighter-rouge">bracketCase</code> operation is the generalized <code class="highlighter-rouge">bracket</code>, also receiving
an <code class="highlighter-rouge">ExitCase</code> in <code class="highlighter-rouge">release</code> in order to distinguish between:</p>

<ol>
  <li>successful completion</li>
  <li>completion in error</li>
  <li>cancellation</li>
</ol>

<p>Usage sample:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">java.io.BufferedReader</span>
<span class="k">import</span> <span class="nn">cats.effect.IO</span>
<span class="k">import</span> <span class="nn">cats.effect.ExitCase.</span><span class="o">{</span><span class="nc">Completed</span><span class="o">,</span> <span class="nc">Error</span><span class="o">,</span> <span class="nc">Canceled</span><span class="o">}</span>

<span class="k">def</span> <span class="n">readLine</span><span class="o">(</span><span class="n">in</span><span class="k">:</span> <span class="kt">BufferedReader</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">IO</span><span class="o">.</span><span class="n">pure</span><span class="o">(</span><span class="n">in</span><span class="o">).</span><span class="n">bracketCase</span> <span class="o">{</span> <span class="n">in</span> <span class="k">=&gt;</span>
    <span class="nc">IO</span><span class="o">(</span><span class="n">in</span><span class="o">.</span><span class="n">readLine</span><span class="o">())</span>
  <span class="o">}</span> <span class="o">{</span> 
    <span class="k">case</span> <span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="nc">Completed</span> <span class="o">|</span> <span class="nc">Error</span><span class="o">(</span><span class="k">_</span><span class="o">))</span> <span class="k">=&gt;</span>
      <span class="c1">// Do nothing
</span>      <span class="nc">IO</span><span class="o">.</span><span class="n">unit</span>
    <span class="k">case</span> <span class="o">(</span><span class="n">in</span><span class="o">,</span> <span class="nc">Canceled</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="nc">IO</span><span class="o">(</span><span class="n">in</span><span class="o">.</span><span class="n">close</span><span class="o">())</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>In this example we are only closing the passed resource in case
cancellation occurred. As to why we’re doing this — consider that 
the <code class="highlighter-rouge">BufferedReader</code> reference was given to us and usually the 
producer of such a resource should also be in charge of releasing 
it. If this function would release the given <code class="highlighter-rouge">BufferedReader</code> on
a successful result, then this would be a flawed implementation.</p>

<p>Remember the age old C++ idiom of “<em>resource acquisition is 
initialization (RAII)</em>”, which says that the lifetime of a resource
should be tied to the lifetime of its parent.</p>

<p>But in case we detect cancellation, we might want to close that 
resource, because in the case of a cancellation event, we might
not have a “run-loop” active after this <code class="highlighter-rouge">IO</code> returns its result,
so there might not be anybody available to release it.</p>

<h2 id="conversions">Conversions</h2>

<p>There are two useful operations defined in the <code class="highlighter-rouge">IO</code> companion object to lift both a scala <code class="highlighter-rouge">Future</code> and an <code class="highlighter-rouge">Either</code> into <code class="highlighter-rouge">IO</code>.</p>

<h3 id="fromfuture">fromFuture</h3>

<p>Constructs an <code class="highlighter-rouge">IO</code> which evaluates the given <code class="highlighter-rouge">Future</code> and produces either a result or a failure. It is defined as follow:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.IO</span>
<span class="k">import</span> <span class="nn">scala.concurrent.Future</span>

<span class="k">def</span> <span class="n">fromFuture</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">iof</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Future</span><span class="o">[</span><span class="kt">A</span><span class="o">]])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
</code></pre></div></div>

<p>Because <code class="highlighter-rouge">Future</code> eagerly evaluates, as well as because it memoizes, this function takes its parameter as an <code class="highlighter-rouge">IO</code>, which could be lazily evaluated. If this laziness is appropriately threaded back to the definition site of the <code class="highlighter-rouge">Future</code>, it ensures that the computation is fully managed by <code class="highlighter-rouge">IO</code> and thus referentially transparent.</p>

<p>Lazy evaluation, equivalent with by-name parameters:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.</span><span class="o">{</span><span class="nc">ContextShift</span><span class="o">,</span> <span class="nc">IO</span><span class="o">}</span>

<span class="k">import</span> <span class="nn">scala.concurrent.Future</span>
<span class="k">import</span> <span class="nn">scala.concurrent.ExecutionContext</span>
<span class="k">import</span> <span class="nn">ExecutionContext.Implicits.global</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="n">contextShift</span><span class="k">:</span> <span class="kt">ContextShift</span><span class="o">[</span><span class="kt">IO</span><span class="o">]</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">.</span><span class="n">contextShift</span><span class="o">(</span><span class="nc">ExecutionContext</span><span class="o">.</span><span class="n">global</span><span class="o">)</span>

<span class="nc">IO</span><span class="o">.</span><span class="n">fromFuture</span><span class="o">(</span><span class="nc">IO</span> <span class="o">{</span>
  <span class="nc">Future</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="s">"I come from the Future!"</span><span class="o">))</span>
<span class="o">})</span>
</code></pre></div></div>

<p>Eager evaluation:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">f</span> <span class="k">=</span> <span class="nc">Future</span><span class="o">.</span><span class="n">successful</span><span class="o">(</span><span class="s">"I come from the Future!"</span><span class="o">)</span>

<span class="nc">IO</span><span class="o">.</span><span class="n">fromFuture</span><span class="o">(</span><span class="nc">IO</span><span class="o">.</span><span class="n">pure</span><span class="o">(</span><span class="n">f</span><span class="o">))</span>
</code></pre></div></div>

<h3 id="fromeither">fromEither</h3>

<p>Lifts an <code class="highlighter-rouge">Either[Throwable, A]</code> into the <code class="highlighter-rouge">IO[A]</code> context raising the throwable if it exists.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.IO</span>

<span class="k">def</span> <span class="n">fromEither</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">e</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">Throwable</span>, <span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">e</span><span class="o">.</span><span class="n">fold</span><span class="o">(</span><span class="nc">IO</span><span class="o">.</span><span class="n">raiseError</span><span class="o">,</span> <span class="nc">IO</span><span class="o">.</span><span class="n">pure</span><span class="o">)</span>
</code></pre></div></div>

<h2 id="error-handling">Error Handling</h2>

<p>Since there is an instance of <code class="highlighter-rouge">MonadError[IO, Throwable]</code> available in Cats Effect, all the error handling is done through it. This means you can use all the operations available for <code class="highlighter-rouge">MonadError</code> and thus for <code class="highlighter-rouge">ApplicativeError</code> on <code class="highlighter-rouge">IO</code> as long as the error type is a <code class="highlighter-rouge">Throwable</code>. Operations such as <code class="highlighter-rouge">raiseError</code>, <code class="highlighter-rouge">attempt</code>, <code class="highlighter-rouge">handleErrorWith</code>, <code class="highlighter-rouge">recoverWith</code>, etc. Just make sure you have the syntax import in scope such as <code class="highlighter-rouge">cats.implicits._</code>.</p>

<h3 id="raiseerror">raiseError</h3>

<p>Constructs an <code class="highlighter-rouge">IO</code> which sequences the specified exception.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.IO</span>

<span class="k">val</span> <span class="n">boom</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">.</span><span class="n">raiseError</span><span class="o">(</span><span class="k">new</span> <span class="nc">Exception</span><span class="o">(</span><span class="s">"boom"</span><span class="o">))</span>
<span class="n">boom</span><span class="o">.</span><span class="n">unsafeRunSync</span><span class="o">()</span>
</code></pre></div></div>

<h3 id="attempt">attempt</h3>

<p>Materializes any sequenced exceptions into value space, where they may be handled. This is analogous to the <code class="highlighter-rouge">catch</code> clause in <code class="highlighter-rouge">try</code>/<code class="highlighter-rouge">catch</code>, being the inverse of <code class="highlighter-rouge">IO.raiseError</code>. Example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.IO</span>

<span class="k">val</span> <span class="n">boom</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">.</span><span class="n">raiseError</span><span class="o">(</span><span class="k">new</span> <span class="nc">Exception</span><span class="o">(</span><span class="s">"boom"</span><span class="o">))</span>
<span class="n">boom</span><span class="o">.</span><span class="n">attempt</span><span class="o">.</span><span class="n">unsafeRunSync</span><span class="o">()</span>
</code></pre></div></div>

<p>Look at the <a href="https://github.com/typelevel/cats/blob/master/core/src/main/scala/cats/MonadError.scala">MonadError</a> typeclass for more.</p>

<h3 id="example-retrying-with-exponential-backoff">Example: Retrying with Exponential Backoff</h3>

<p>With <code class="highlighter-rouge">IO</code> you can easily model a loop that retries evaluation until success or some other condition is met.</p>

<p>For example here’s a way to implement retries with exponential back-off:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.</span><span class="o">{</span><span class="nc">IO</span><span class="o">,</span> <span class="nc">Timer</span><span class="o">}</span>

<span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">def</span> <span class="n">retryWithBackoff</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">ioa</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">initialDelay</span><span class="k">:</span> <span class="kt">FiniteDuration</span><span class="o">,</span> <span class="n">maxRetries</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
  <span class="o">(</span><span class="k">implicit</span> <span class="n">timer</span><span class="k">:</span> <span class="kt">Timer</span><span class="o">[</span><span class="kt">IO</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>

  <span class="n">ioa</span><span class="o">.</span><span class="n">handleErrorWith</span> <span class="o">{</span> <span class="n">error</span> <span class="k">=&gt;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">maxRetries</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
      <span class="nc">IO</span><span class="o">.</span><span class="n">sleep</span><span class="o">(</span><span class="n">initialDelay</span><span class="o">)</span> <span class="o">*&gt;</span> <span class="n">retryWithBackoff</span><span class="o">(</span><span class="n">ioa</span><span class="o">,</span> <span class="n">initialDelay</span> <span class="o">*</span> <span class="mi">2</span><span class="o">,</span> <span class="n">maxRetries</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
    <span class="k">else</span>
      <span class="nc">IO</span><span class="o">.</span><span class="n">raiseError</span><span class="o">(</span><span class="n">error</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="thread-shifting">Thread Shifting</h2>

<p><code class="highlighter-rouge">IO</code> provides a function <code class="highlighter-rouge">shift</code> to give you more control over the execution of your operations.</p>

<h3 id="shift">shift</h3>

<p>Note there are 2 overloads of the <code class="highlighter-rouge">IO.shift</code> function:</p>

<ul>
  <li>One that takes a <a href="/cats-effect/datatypes/contextshift.html">ContextShift</a> that manages the thread-pool used to trigger async boundaries.</li>
  <li>Another that takes a Scala <code class="highlighter-rouge">ExecutionContext</code> as the thread-pool.</li>
</ul>

<p>Please use the former by default and use the latter only for fine-grained control over the thread pool in use.</p>

<p>By default, <code class="highlighter-rouge">Cats Effect</code> can provide instance of <code class="highlighter-rouge">ContextShift[IO]</code> that manages thread-pools,
but only if there’s an <code class="highlighter-rouge">ExecutionContext</code> in scope or if <a href="/cats-effect/datatypes/ioapp.html">IOApp</a> is used:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.</span><span class="o">{</span><span class="nc">ContextShift</span><span class="o">,</span> <span class="nc">IO</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">scala.concurrent.ExecutionContext.Implicits.global</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="n">contextShift</span><span class="k">:</span> <span class="kt">ContextShift</span><span class="o">[</span><span class="kt">IO</span><span class="o">]</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">.</span><span class="n">contextShift</span><span class="o">(</span><span class="n">global</span><span class="o">)</span>
</code></pre></div></div>

<p>We can introduce an asynchronous boundary in the <code class="highlighter-rouge">flatMap</code> chain before a certain task:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">task</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="s">"task"</span><span class="o">))</span>

<span class="nc">IO</span><span class="o">.</span><span class="n">shift</span><span class="o">(</span><span class="n">contextShift</span><span class="o">).</span><span class="n">flatMap</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="n">task</span><span class="o">)</span>
</code></pre></div></div>

<p>Note that the <code class="highlighter-rouge">ContextShift</code> value is taken implicitly from the context so you can just do this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IO</span><span class="o">.</span><span class="n">shift</span><span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="n">task</span><span class="o">)</span>
</code></pre></div></div>

<p>Or using <code class="highlighter-rouge">Cats</code> syntax:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="nc">IO</span><span class="o">.</span><span class="n">shift</span> <span class="o">*&gt;</span> <span class="n">task</span>
<span class="c1">// equivalent to
</span><span class="n">implicitly</span><span class="o">[</span><span class="kt">ContextShift</span><span class="o">[</span><span class="kt">IO</span><span class="o">]].</span><span class="n">shift</span> <span class="o">*&gt;</span> <span class="n">task</span>
</code></pre></div></div>

<p>Or we can specify an asynchronous boundary “after” the evaluation of a certain task:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">task</span><span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="nc">IO</span><span class="o">.</span><span class="n">shift</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="n">a</span><span class="o">))</span>
</code></pre></div></div>

<p>Or using <code class="highlighter-rouge">Cats</code> syntax:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">task</span> <span class="o">&lt;*</span> <span class="nc">IO</span><span class="o">.</span><span class="n">shift</span>
<span class="c1">// equivalent to
</span><span class="n">task</span> <span class="o">&lt;*</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">ContextShift</span><span class="o">[</span><span class="kt">IO</span><span class="o">]].</span><span class="n">shift</span>
</code></pre></div></div>

<p>Example of where this might be useful:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">java.util.concurrent.Executors</span>

<span class="k">import</span> <span class="nn">cats.effect.IO</span>
<span class="k">import</span> <span class="nn">scala.concurrent.ExecutionContext</span>

<span class="k">val</span> <span class="n">cachedThreadPool</span> <span class="k">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="n">newCachedThreadPool</span><span class="o">()</span>
<span class="k">val</span> <span class="nc">BlockingFileIO</span>   <span class="k">=</span> <span class="nc">ExecutionContext</span><span class="o">.</span><span class="n">fromExecutor</span><span class="o">(</span><span class="n">cachedThreadPool</span><span class="o">)</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="nc">Main</span> <span class="k">=</span> <span class="nc">ExecutionContext</span><span class="o">.</span><span class="n">global</span>

<span class="k">val</span> <span class="n">ioa</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="k">_</span>     <span class="k">&lt;-</span> <span class="nc">IO</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="s">"Enter your name: "</span><span class="o">))</span>
    <span class="k">_</span>     <span class="k">&lt;-</span> <span class="nc">IO</span><span class="o">.</span><span class="n">shift</span><span class="o">(</span><span class="nc">BlockingFileIO</span><span class="o">)</span>
    <span class="n">name</span>  <span class="k">&lt;-</span> <span class="nc">IO</span><span class="o">(</span><span class="n">scala</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="nc">StdIn</span><span class="o">.</span><span class="n">readLine</span><span class="o">())</span>
    <span class="k">_</span>     <span class="k">&lt;-</span> <span class="nc">IO</span><span class="o">.</span><span class="n">shift</span><span class="o">(</span><span class="nc">Main</span><span class="o">)</span>
    <span class="k">_</span>     <span class="k">&lt;-</span> <span class="nc">IO</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Welcome $name!"</span><span class="o">))</span>
    <span class="k">_</span>     <span class="k">&lt;-</span> <span class="nc">IO</span><span class="o">(</span><span class="n">cachedThreadPool</span><span class="o">.</span><span class="n">shutdown</span><span class="o">())</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="o">()</span>
</code></pre></div></div>

<p>We start by asking the user to enter its name and next we thread-shift to the <code class="highlighter-rouge">BlockingFileIO</code> execution context because we expect the following action to block on the thread for a long time and we don’t want that to happen in the main thread of execution. After the <code class="highlighter-rouge">expensive IO operation</code> (readLine) gets back with a response we thread-shift back to the main execution context defined as an implicit value, and finally the program ends by showing a message in the console and shutting down a thread pool, all actions run in the main execution context.</p>

<p>Another somewhat less common application of <code class="highlighter-rouge">shift</code> is to reset the thread stack and yield control back to the underlying pool. For example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.</span><span class="o">{</span><span class="nc">ContextShift</span><span class="o">,</span> <span class="nc">IO</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">scala.concurrent.ExecutionContext</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="n">contextShift</span><span class="k">:</span> <span class="kt">ContextShift</span><span class="o">[</span><span class="kt">IO</span><span class="o">]</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">.</span><span class="n">contextShift</span><span class="o">(</span><span class="nc">ExecutionContext</span><span class="o">.</span><span class="n">global</span><span class="o">)</span>

<span class="k">lazy</span> <span class="k">val</span> <span class="n">doStuff</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="s">"stuff"</span><span class="o">))</span>

<span class="k">lazy</span> <span class="k">val</span> <span class="n">repeat</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">doStuff</span>
    <span class="k">_</span> <span class="k">&lt;-</span> <span class="nc">IO</span><span class="o">.</span><span class="n">shift</span>
    <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">repeat</span>
<span class="o">}</span> <span class="k">yield</span> <span class="o">()</span>
</code></pre></div></div>

<p>In this example, <code class="highlighter-rouge">repeat</code> is a very long running <code class="highlighter-rouge">IO</code> (infinite, in fact!) which will just hog the underlying thread resource for as long as it continues running.  This can be a bit of a problem, and so we inject the <code class="highlighter-rouge">IO.shift</code> which yields control back to the underlying thread pool, giving it a chance to reschedule things and provide better fairness. This shifting also “bounces” the thread stack, popping all the way back to the thread pool and effectively trampolining the remainder of the computation. Although the thread-shifting is not completely necessary, it might help in some cases to alleviate the use of the main thread pool.</p>

<p>Thus, this function has four important use cases:</p>
<ul>
  <li>Shifting blocking actions off of the main compute pool.</li>
  <li>Defensively re-shifting asynchronous continuations back to the main compute pool.</li>
  <li>Yielding control to some underlying pool for fairness reasons.</li>
  <li>Preventing an overflow of the call stack in the case of improperly constructed <code class="highlighter-rouge">async</code> actions.</li>
</ul>

<p><code class="highlighter-rouge">IO</code> is trampolined for all <code class="highlighter-rouge">synchronous</code> and <code class="highlighter-rouge">asynchronous</code> joins. This means that you can safely call <code class="highlighter-rouge">flatMap</code> in a recursive function of arbitrary depth, without fear of blowing the stack. So you can do this for example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.IO</span>

<span class="k">def</span> <span class="n">signal</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">.</span><span class="n">async</span><span class="o">(</span><span class="k">_</span><span class="o">(</span><span class="nc">Right</span><span class="o">(</span><span class="n">a</span><span class="o">)))</span>

<span class="k">def</span> <span class="n">loop</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">signal</span><span class="o">(</span><span class="n">n</span><span class="o">).</span><span class="n">flatMap</span> <span class="o">{</span> <span class="n">x</span> <span class="k">=&gt;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="n">loop</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="k">else</span> <span class="nc">IO</span><span class="o">.</span><span class="n">pure</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<h2 id="parallelism">Parallelism</h2>

<p>Since the introduction of the <a href="https://github.com/typelevel/cats/blob/master/core/src/main/scala/cats/Parallel.scala">Parallel</a> typeclasss in the Cats library and its <code class="highlighter-rouge">IO</code> instance, it became possible to execute two or more given <code class="highlighter-rouge">IO</code>s in parallel.</p>

<p>Note: all parallel operations require an implicit <code class="highlighter-rouge">ContextShift[IO]</code> in scope
(see <a href="/cats-effect/datatypes/contextshift.html">ContextShift</a>). You have a <code class="highlighter-rouge">ContextShift</code> in scope if:</p>

<ol>
  <li>via usage of <a href="/cats-effect/datatypes/ioapp.html">IOApp</a> that gives you a <code class="highlighter-rouge">ContextShift</code> by default</li>
  <li>the user provides a custom <code class="highlighter-rouge">ContextShift</code>, which can be created using <code class="highlighter-rouge">IO.contextShift(executionContext)</code></li>
</ol>

<h3 id="parmapn">parMapN</h3>

<p>It has the potential to run an arbitrary number of <code class="highlighter-rouge">IO</code>s in parallel, and it allows you to apply a function to the result (as in <code class="highlighter-rouge">map</code>). It finishes processing when all the <code class="highlighter-rouge">IO</code>s are completed, either successfully or with a failure. For example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.</span><span class="o">{</span><span class="nc">ContextShift</span><span class="o">,</span> <span class="nc">IO</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">cats.implicits._</span>

<span class="k">import</span> <span class="nn">scala.concurrent.ExecutionContext</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="n">contextShift</span><span class="k">:</span> <span class="kt">ContextShift</span><span class="o">[</span><span class="kt">IO</span><span class="o">]</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">.</span><span class="n">contextShift</span><span class="o">(</span><span class="nc">ExecutionContext</span><span class="o">.</span><span class="n">global</span><span class="o">)</span>

<span class="k">val</span> <span class="n">ioA</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="s">"Running ioA"</span><span class="o">))</span>
<span class="k">val</span> <span class="n">ioB</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="s">"Running ioB"</span><span class="o">))</span>
<span class="k">val</span> <span class="n">ioC</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="s">"Running ioC"</span><span class="o">))</span>

<span class="c1">// make sure that you have an implicit ContextShift[IO] in scope. 
</span><span class="k">val</span> <span class="n">program</span> <span class="k">=</span> <span class="o">(</span><span class="n">ioA</span><span class="o">,</span> <span class="n">ioB</span><span class="o">,</span> <span class="n">ioC</span><span class="o">).</span><span class="n">parMapN</span> <span class="o">{</span> <span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">()</span> <span class="o">}</span>

<span class="n">program</span><span class="o">.</span><span class="n">unsafeRunSync</span><span class="o">()</span>
<span class="c1">//=&gt; Running ioB
//=&gt; Running ioC
//=&gt; Running ioA
</span><span class="o">()</span>
</code></pre></div></div>

<p>If any of the <code class="highlighter-rouge">IO</code>s completes with a failure then the result of the whole computation will be failed, while the unfinished tasks get cancelled. Example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.</span><span class="o">{</span><span class="nc">ContextShift</span><span class="o">,</span> <span class="nc">ExitCase</span><span class="o">,</span> <span class="nc">IO</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">cats.implicits._</span>

<span class="k">import</span> <span class="nn">scala.concurrent.ExecutionContext</span>
<span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="n">contextShift</span><span class="k">:</span> <span class="kt">ContextShift</span><span class="o">[</span><span class="kt">IO</span><span class="o">]</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">.</span><span class="n">contextShift</span><span class="o">(</span><span class="nc">ExecutionContext</span><span class="o">.</span><span class="n">global</span><span class="o">)</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="n">timer</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">.</span><span class="n">timer</span><span class="o">(</span><span class="nc">ExecutionContext</span><span class="o">.</span><span class="n">global</span><span class="o">)</span>

<span class="k">val</span> <span class="n">a</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">.</span><span class="n">raiseError</span><span class="o">[</span><span class="kt">Unit</span><span class="o">](</span><span class="k">new</span> <span class="nc">Exception</span><span class="o">(</span><span class="s">"boom"</span><span class="o">))</span> <span class="o">&lt;*</span> <span class="nc">IO</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="s">"Running ioA"</span><span class="o">))</span>
<span class="k">val</span> <span class="n">b</span> <span class="k">=</span> <span class="o">(</span><span class="nc">IO</span><span class="o">.</span><span class="n">sleep</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span> <span class="o">*&gt;</span> <span class="nc">IO</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="s">"Running ioB"</span><span class="o">)))</span>
  <span class="o">.</span><span class="n">guaranteeCase</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">ExitCase</span><span class="o">.</span><span class="nc">Canceled</span> <span class="k">=&gt;</span> <span class="nc">IO</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="s">"ioB was canceled!"</span><span class="o">))</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">IO</span><span class="o">.</span><span class="n">unit</span>
  <span class="o">}</span>

<span class="k">val</span> <span class="n">parFailure</span> <span class="k">=</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">).</span><span class="n">parMapN</span> <span class="o">{</span> <span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">()</span> <span class="o">}</span>

<span class="n">parFailure</span><span class="o">.</span><span class="n">attempt</span><span class="o">.</span><span class="n">unsafeRunSync</span><span class="o">()</span>
<span class="c1">//=&gt; ioB was canceled!
//=&gt; java.lang.Exception: boom
//=&gt;  ... 43 elided
</span><span class="o">()</span>
</code></pre></div></div>

<p>If one of the tasks fails immediately, then the other gets canceled and the computation completes immediately, so in this example the pairing via <code class="highlighter-rouge">parMapN</code> will not wait for 10 seconds before emitting the error:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.</span><span class="o">{</span><span class="nc">ContextShift</span><span class="o">,</span> <span class="nc">Timer</span><span class="o">,</span> <span class="nc">IO</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">cats.implicits._</span>

<span class="k">import</span> <span class="nn">scala.concurrent.ExecutionContext</span>
<span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="n">contextShift</span><span class="k">:</span> <span class="kt">ContextShift</span><span class="o">[</span><span class="kt">IO</span><span class="o">]</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">.</span><span class="n">contextShift</span><span class="o">(</span><span class="nc">ExecutionContext</span><span class="o">.</span><span class="n">global</span><span class="o">)</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="n">timer</span><span class="k">:</span> <span class="kt">Timer</span><span class="o">[</span><span class="kt">IO</span><span class="o">]</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">.</span><span class="n">timer</span><span class="o">(</span><span class="nc">ExecutionContext</span><span class="o">.</span><span class="n">global</span><span class="o">)</span>

<span class="k">val</span> <span class="n">ioA</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">.</span><span class="n">sleep</span><span class="o">(</span><span class="mf">10.</span><span class="n">seconds</span><span class="o">)</span> <span class="o">*&gt;</span> <span class="nc">IO</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="s">"Delayed!"</span><span class="o">))</span>
<span class="k">val</span> <span class="n">ioB</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">.</span><span class="n">raiseError</span><span class="o">[</span><span class="kt">Unit</span><span class="o">](</span><span class="k">new</span> <span class="nc">Exception</span><span class="o">(</span><span class="s">"dummy"</span><span class="o">))</span>

<span class="o">(</span><span class="n">ioA</span><span class="o">,</span> <span class="n">ioB</span><span class="o">).</span><span class="n">parMapN</span><span class="o">((</span><span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">())</span>
</code></pre></div></div>

<h3 id="parsequence">parSequence</h3>

<p>If you have a list of IO, and you want a single IO with the result list you can use <code class="highlighter-rouge">parSequence</code> which executes the IO tasks in parallel.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.data.NonEmptyList</span>
<span class="k">import</span> <span class="nn">cats.effect.</span><span class="o">{</span><span class="nc">ContextShift</span><span class="o">,</span> <span class="nc">Timer</span><span class="o">,</span> <span class="nc">IO</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">cats.syntax.parallel._</span>

<span class="k">import</span> <span class="nn">scala.concurrent.ExecutionContext</span> 

<span class="c1">// Needed for IO.start to do a logical thread fork
</span><span class="k">implicit</span> <span class="k">val</span> <span class="n">cs</span><span class="k">:</span> <span class="kt">ContextShift</span><span class="o">[</span><span class="kt">IO</span><span class="o">]</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">.</span><span class="n">contextShift</span><span class="o">(</span><span class="nc">ExecutionContext</span><span class="o">.</span><span class="n">global</span><span class="o">)</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="n">timer</span><span class="k">:</span> <span class="kt">Timer</span><span class="o">[</span><span class="kt">IO</span><span class="o">]</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">.</span><span class="n">timer</span><span class="o">(</span><span class="nc">ExecutionContext</span><span class="o">.</span><span class="n">global</span><span class="o">)</span>

<span class="k">val</span> <span class="n">anIO</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>

<span class="k">val</span> <span class="n">aLotOfIOs</span> <span class="k">=</span> 
  <span class="nc">NonEmptyList</span><span class="o">.</span><span class="n">of</span><span class="o">(</span><span class="n">anIO</span><span class="o">,</span> <span class="n">anIO</span><span class="o">)</span>

<span class="k">val</span> <span class="n">ioOfList</span> <span class="k">=</span> <span class="n">aLotOfIOs</span><span class="o">.</span><span class="n">parSequence</span>
</code></pre></div></div>

<p>There is also <code class="highlighter-rouge">cats.Traverse.sequence</code> which does this synchronously.</p>

<h3 id="partraverse">parTraverse</h3>

<p>If you have a list of data and a way of turning each item into an IO, but you want a single IO for the results you can use <code class="highlighter-rouge">parTraverse</code> to run the steps in parallel.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.data.NonEmptyList</span>
<span class="k">import</span> <span class="nn">cats.effect.</span><span class="o">{</span><span class="nc">ContextShift</span><span class="o">,</span> <span class="nc">Timer</span><span class="o">,</span> <span class="nc">IO</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">cats.syntax.parallel._</span>

<span class="k">import</span> <span class="nn">scala.concurrent.ExecutionContext</span> 

<span class="c1">// Needed for IO.start to do a logical thread fork
</span><span class="k">implicit</span> <span class="k">val</span> <span class="n">cs</span><span class="k">:</span> <span class="kt">ContextShift</span><span class="o">[</span><span class="kt">IO</span><span class="o">]</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">.</span><span class="n">contextShift</span><span class="o">(</span><span class="nc">ExecutionContext</span><span class="o">.</span><span class="n">global</span><span class="o">)</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="n">timer</span><span class="k">:</span> <span class="kt">Timer</span><span class="o">[</span><span class="kt">IO</span><span class="o">]</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">.</span><span class="n">timer</span><span class="o">(</span><span class="nc">ExecutionContext</span><span class="o">.</span><span class="n">global</span><span class="o">)</span>

<span class="k">val</span> <span class="n">results</span> <span class="k">=</span> <span class="nc">NonEmptyList</span><span class="o">.</span><span class="n">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">).</span><span class="n">parTraverse</span> <span class="o">{</span> <span class="n">i</span> <span class="k">=&gt;</span>
  <span class="nc">IO</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>There is also <code class="highlighter-rouge">cats.Traverse.traverse</code> which will run each step synchronously.</p>

<h2 id="unsafe-operations">“Unsafe” Operations</h2>

<p>We have been using some “unsafe” operations pretty much everywhere in the previous examples but we never explained any of them, so here it goes. All of the operations prefixed with <code class="highlighter-rouge">unsafe</code> are impure functions and perform side effects (for example Haskell has <code class="highlighter-rouge">unsafePerformIO</code>). But don’t be scared by the name! You should write your programs in a monadic way using functions such as <code class="highlighter-rouge">map</code> and <code class="highlighter-rouge">flatMap</code> to compose other functions and ideally you should just call one of these unsafe operations only <strong>once</strong>, at the very end of your program.</p>

<h3 id="unsaferunsync">unsafeRunSync</h3>

<p>Produces the result by running the encapsulated effects as impure side effects.</p>

<p>If any component of the computation is asynchronous, the current thread will block awaiting the results of the async computation. On JavaScript, an exception will be thrown instead to avoid generating a deadlock. By default, this blocking will be unbounded. To limit the thread block to some fixed time, use <code class="highlighter-rouge">unsafeRunTimed</code> instead.</p>

<p>Any exceptions raised within the effect will be re-thrown during evaluation.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IO</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="s">"Sync!"</span><span class="o">)).</span><span class="n">unsafeRunSync</span><span class="o">()</span>
<span class="c1">// Sync!
</span></code></pre></div></div>

<h3 id="unsaferunasync">unsafeRunAsync</h3>

<p>Passes the result of the encapsulated effects to the given callback by running them as impure side effects.</p>

<p>Any exceptions raised within the effect will be passed to the callback in the <code class="highlighter-rouge">Either</code>. The callback will be invoked at most <em>once</em>. Note that it is very possible to construct an <code class="highlighter-rouge">IO</code> which never returns while still never blocking a thread, and attempting to evaluate that <code class="highlighter-rouge">IO</code> with this method will result in a situation where the callback is <em>never</em> invoked.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IO</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="s">"Async!"</span><span class="o">)).</span><span class="n">unsafeRunAsync</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="o">())</span>
<span class="c1">// Async!
</span></code></pre></div></div>

<h3 id="unsaferuncancelable">unsafeRunCancelable</h3>

<p>Evaluates the source <code class="highlighter-rouge">IO</code>, passing the result of the encapsulated effects to the given callback. Note that this has the potential to be interrupted.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IO</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="s">"Potentially cancelable!"</span><span class="o">)).</span><span class="n">unsafeRunCancelable</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="o">())</span>
<span class="c1">// Potentially cancelable!
// res59: cats.effect.package.CancelToken[IO] = Suspend(
//   thunk = cats.effect.internals.IOConnection$Impl$$Lambda$6829/301629009@7eee04b5
// )
</span></code></pre></div></div>

<h3 id="unsaferuntimed">unsafeRunTimed</h3>

<p>Similar to <code class="highlighter-rouge">unsafeRunSync</code>, except with a bounded blocking duration when awaiting asynchronous results.</p>

<p>Please note that the <code class="highlighter-rouge">limit</code> parameter does not limit the time of the total computation, but rather acts as an upper bound on any <em>individual</em> asynchronous block.  Thus, if you pass a limit of <code class="highlighter-rouge">5 seconds</code> to an <code class="highlighter-rouge">IO</code> consisting solely of synchronous actions, the evaluation may take considerably longer than 5 seconds!</p>

<p>Furthermore, if you pass a limit of <code class="highlighter-rouge">5 seconds</code> to an <code class="highlighter-rouge">IO</code> consisting of several asynchronous actions joined together, evaluation may take up to <code class="highlighter-rouge">n * 5 seconds</code>, where <code class="highlighter-rouge">n</code> is the number of joined async actions.</p>

<p>As soon as an async blocking limit is hit, evaluation “immediately” aborts and <code class="highlighter-rouge">None</code> is returned.</p>

<p>Please note that this function is intended for <strong>testing</strong> purposes; it should never appear in your mainline production code!  It is absolutely not an appropriate function to use if you want to implement timeouts, or anything similar. If you need that sort of functionality, you should be using a streaming library (like <a href="https://github.com/functional-streams-for-scala/fs2">fs2</a> or <a href="https://monix.io/">Monix</a>).</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="nc">IO</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="s">"Timed!"</span><span class="o">)).</span><span class="n">unsafeRunTimed</span><span class="o">(</span><span class="mf">5.</span><span class="n">seconds</span><span class="o">)</span>
</code></pre></div></div>

<h3 id="unsafetofuture">unsafeToFuture</h3>

<p>Evaluates the effect and produces the result in a <code class="highlighter-rouge">Future</code>.</p>

<p>This is similar to <code class="highlighter-rouge">unsafeRunAsync</code> in that it evaluates the <code class="highlighter-rouge">IO</code> as a side effect in a non-blocking fashion, but uses a <code class="highlighter-rouge">Future</code> rather than an explicit callback.  This function should really only be used if interoperating with legacy code which uses Scala futures.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IO</span><span class="o">(</span><span class="s">"Gimme a Future!"</span><span class="o">).</span><span class="n">unsafeToFuture</span><span class="o">()</span>
</code></pre></div></div>

<h2 id="best-practices">Best Practices</h2>

<p>This section presents some best practices for working with <code class="highlighter-rouge">IO</code>:</p>

<h3 id="keep-granularity">Keep Granularity</h3>

<p>It’s better to keep the granularity, so please don’t do something like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IO</span> <span class="o">{</span>
  <span class="n">readingFile</span>
  <span class="n">writingToDatabase</span>
  <span class="n">sendBytesOverTcp</span>
  <span class="n">launchMissiles</span>
<span class="o">}</span>
</code></pre></div></div>

<p>In FP we embrace reasoning about our programs and since <code class="highlighter-rouge">IO</code> is a <code class="highlighter-rouge">Monad</code> you can compose bigger programs from small ones in a <code class="highlighter-rouge">for-comprehension</code>.
For example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">program</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="n">data</span> <span class="k">&lt;-</span> <span class="n">readFile</span>
    <span class="k">_</span>    <span class="k">&lt;-</span> <span class="n">writeToDatabase</span><span class="o">(</span><span class="n">data</span><span class="o">)</span>
    <span class="k">_</span>    <span class="k">&lt;-</span> <span class="n">sendBytesOverTcp</span><span class="o">(</span><span class="n">data</span><span class="o">)</span>
    <span class="k">_</span>    <span class="k">&lt;-</span> <span class="n">launchMissiles</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="o">()</span>
</code></pre></div></div>

<p>Each step of the comprehension is a small program, and the resulting <code class="highlighter-rouge">program</code> is a composition of all those small steps,
which is compositional with other programs. <code class="highlighter-rouge">IO</code> values compose.</p>

<h3 id="use-pure-functions-in-map--flatmap">Use pure functions in map / flatMap</h3>

<p>When using <code class="highlighter-rouge">map</code> or <code class="highlighter-rouge">flatMap</code> it is not recommended to pass a side effectful function, as mapping functions should also be pure.
So this should be avoided:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IO</span><span class="o">.</span><span class="n">pure</span><span class="o">(</span><span class="mi">123</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">n</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"NOT RECOMMENDED! $n"</span><span class="o">))</span>
</code></pre></div></div>

<p>This too should be avoided, because the side effect is not suspended in the returned <code class="highlighter-rouge">IO</code> value:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IO</span><span class="o">.</span><span class="n">pure</span><span class="o">(</span><span class="mi">123</span><span class="o">).</span><span class="n">flatMap</span> <span class="o">{</span> <span class="n">n</span> <span class="k">=&gt;</span>
  <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"NOT RECOMMENDED! $n"</span><span class="o">)</span>
  <span class="nc">IO</span><span class="o">.</span><span class="n">unit</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The correct approach would be this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IO</span><span class="o">.</span><span class="n">pure</span><span class="o">(</span><span class="mi">123</span><span class="o">).</span><span class="n">flatMap</span> <span class="o">{</span> <span class="n">n</span> <span class="k">=&gt;</span>
  <span class="c1">// Properly suspending the side effect
</span>  <span class="nc">IO</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"RECOMMENDED! $n"</span><span class="o">))</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Note that as far as the actual behavior of <code class="highlighter-rouge">IO</code> is concerned, something like <code class="highlighter-rouge">IO.pure(x).map(f)</code> is equivalent with <code class="highlighter-rouge">IO(f(x))</code> and <code class="highlighter-rouge">IO.pure(x).flatMap(f)</code> is equivalent with <code class="highlighter-rouge">IO.suspend(f(x))</code>.</p>

<p>But you should not rely on this behavior, because it is NOT described by the laws required by the <code class="highlighter-rouge">Sync</code> type class and those laws are the only guarantees of behavior that you get. For example the above equivalence might be broken in the future in regards to error handling. So this behavior is currently there for safety reasons, but you should regard it as an implementation detail that could change in the future.</p>

<p>Stick with pure functions.</p>



<link rel="stylesheet" type="text/css" href="/cats-effect/css/toc.css"></link>
<script type="text/javascript" src="/cats-effect/js/toc.js"></script>
</section></div></div></div></div><script src="/cats-effect/highlight/highlight.pack.js"></script><script>
// For all code blocks, copy the language from the containing div
// to the inner code tag (where hljs expects it to be)
const langPrefix = 'language-';
document.querySelectorAll(`div[class^='${langPrefix}']`).forEach(function(div) {
  div.classList.forEach(function(cssClass) {
    if (cssClass.startsWith(langPrefix)) {
      const lang = cssClass.substring(langPrefix.length);
      div.querySelectorAll('pre code').forEach(function(code) {
        code.classList.add(lang);
      });
    }
  });
});

hljs.configure({languages:['scala','java','bash']});
hljs.initHighlightingOnLoad();
      </script><script src="/cats-effect/js/toc.js"></script><script>console.info('\x57\x65\x62\x73\x69\x74\x65\x20\x62\x75\x69\x6c\x74\x20\x77\x69\x74\x68\x3a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x5f\x5f\x20\x20\x20\x20\x5f\x5f\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x5f\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x5f\x20\x5f\x5f\x0a\x20\x20\x20\x5f\x5f\x5f\x5f\x5f\x2f\x20\x2f\x5f\x20\x20\x2f\x20\x2f\x5f\x20\x20\x20\x20\x20\x20\x5f\x5f\x5f\x5f\x20\x5f\x5f\x5f\x20\x20\x28\x5f\x29\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x20\x20\x5f\x5f\x5f\x5f\x5f\x28\x5f\x29\x20\x2f\x5f\x5f\x5f\x5f\x20\x20\x5f\x5f\x5f\x5f\x5f\x0a\x20\x20\x2f\x20\x5f\x5f\x5f\x2f\x20\x5f\x5f\x20\x5c\x2f\x20\x5f\x5f\x2f\x5f\x5f\x5f\x5f\x5f\x2f\x20\x5f\x5f\x20\x60\x5f\x5f\x20\x5c\x2f\x20\x2f\x20\x5f\x5f\x5f\x2f\x20\x5f\x5f\x5f\x2f\x20\x5f\x5f\x20\x5c\x2f\x20\x5f\x5f\x5f\x2f\x20\x2f\x20\x5f\x5f\x2f\x20\x5f\x20\x5c\x2f\x20\x5f\x5f\x5f\x2f\x0a\x20\x28\x5f\x5f\x20\x20\x29\x20\x2f\x5f\x2f\x20\x2f\x20\x2f\x5f\x2f\x5f\x5f\x5f\x5f\x5f\x2f\x20\x2f\x20\x2f\x20\x2f\x20\x2f\x20\x2f\x20\x2f\x20\x2f\x5f\x5f\x2f\x20\x2f\x20\x20\x2f\x20\x2f\x5f\x2f\x20\x28\x5f\x5f\x20\x20\x29\x20\x2f\x20\x2f\x5f\x2f\x20\x20\x5f\x5f\x28\x5f\x5f\x20\x20\x29\x0a\x2f\x5f\x5f\x5f\x5f\x2f\x5f\x2e\x5f\x5f\x5f\x2f\x5c\x5f\x5f\x2f\x20\x20\x20\x20\x20\x2f\x5f\x2f\x20\x2f\x5f\x2f\x20\x2f\x5f\x2f\x5f\x2f\x5c\x5f\x5f\x5f\x2f\x5f\x2f\x20\x20\x20\x5c\x5f\x5f\x5f\x5f\x2f\x5f\x5f\x5f\x5f\x2f\x5f\x2f\x5c\x5f\x5f\x2f\x5c\x5f\x5f\x5f\x2f\x5f\x5f\x5f\x5f\x2f\x0a\x0a\x68\x74\x74\x70\x73\x3a\x2f\x2f\x34\x37\x64\x65\x67\x2e\x67\x69\x74\x68\x75\x62\x2e\x69\x6f\x2f\x73\x62\x74\x2d\x6d\x69\x63\x72\x6f\x73\x69\x74\x65\x73')</script><script>((window.gitter = {}).chat = {}).options = {
room: 'typelevel/cats-effect'};</script><script src="https://sidecar.gitter.im/dist/sidecar.v1.js"></script><script src="/cats-effect/js/docs.js"></script></body></html>