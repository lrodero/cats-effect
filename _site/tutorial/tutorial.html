<!DOCTYPE html><html><head><title>Cats Effect: Tutorial</title><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="Cats Effect contributors" /><meta name="description" content="The IO Monad for Scala" /><meta name="og:image" content="/cats-effect/img/poster.png" /><meta name="image" property="og:image" content="/cats-effect/img/poster.png" /><meta name="og:title" content="Cats Effect: Tutorial" /><meta name="title" property="og:title" content="Cats Effect: Tutorial" /><meta name="og:site_name" content="Cats Effect" /><meta name="og:url" content="https://typelevel.org/cats-effect/" /><meta name="og:type" content="website" /><meta name="og:description" content="The IO Monad for Scala" /><link rel="icon" type="image/png" href="/cats-effect/img/favicon.png" /><meta name="twitter:title" content="Cats Effect: Tutorial" /><meta name="twitter:image" content="/cats-effect/img/poster.png" /><meta name="twitter:description" content="The IO Monad for Scala" /><meta name="twitter:card" content="summary_large_image" /><meta name="twitter:creator" content="@typelevel" /><link rel="icon" type="image/png" sizes="16x16" href="/cats-effect/img/favicon16x16.png" /><link rel="icon" type="image/png" sizes="24x24" href="/cats-effect/img/favicon24x24.png" /><link rel="icon" type="image/png" sizes="32x32" href="/cats-effect/img/favicon32x32.png" /><link rel="icon" type="image/png" sizes="48x48" href="/cats-effect/img/favicon48x48.png" /><link rel="icon" type="image/png" sizes="57x57" href="/cats-effect/img/favicon57x57.png" /><link rel="icon" type="image/png" sizes="60x60" href="/cats-effect/img/favicon60x60.png" /><link rel="icon" type="image/png" sizes="64x64" href="/cats-effect/img/favicon64x64.png" /><link rel="icon" type="image/png" sizes="70x70" href="/cats-effect/img/favicon70x70.png" /><link rel="icon" type="image/png" sizes="72x72" href="/cats-effect/img/favicon72x72.png" /><link rel="icon" type="image/png" sizes="76x76" href="/cats-effect/img/favicon76x76.png" /><link rel="icon" type="image/png" sizes="96x96" href="/cats-effect/img/favicon96x96.png" /><link rel="icon" type="image/png" sizes="114x114" href="/cats-effect/img/favicon114x114.png" /><link rel="icon" type="image/png" sizes="120x120" href="/cats-effect/img/favicon120x120.png" /><link rel="icon" type="image/png" sizes="128x128" href="/cats-effect/img/favicon128x128.png" /><link rel="icon" type="image/png" sizes="144x144" href="/cats-effect/img/favicon144x144.png" /><link rel="icon" type="image/png" sizes="150x150" href="/cats-effect/img/favicon150x150.png" /><link rel="icon" type="image/png" sizes="152x152" href="/cats-effect/img/favicon152x152.png" /><link rel="icon" type="image/png" sizes="196x196" href="/cats-effect/img/favicon196x196.png" /><link rel="icon" type="image/png" sizes="310x310" href="/cats-effect/img/favicon310x310.png" /><link rel="icon" type="image/png" sizes="310x150" href="/cats-effect/img/favicon310x150.png" /><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" /><link rel="stylesheet" href="/cats-effect/highlight/styles/atom-one-light.css" /><link rel="stylesheet" href="/cats-effect/css/light-style.css" /><link rel="stylesheet" href="/cats-effect/css/toc.css" /></head><body class="docs"><div id="wrapper"><div id="sidebar-wrapper"><div id="sidebar-brand"><a href="/cats-effect/" class="brand"><div class="brand-wrapper"></div><span>Cats Effect</span></a><button id="main-toggle" class="sidebar-toggle"><span class="close"></span></button></div><div class="sidebar-nav"> <div class="sidebar-nav-item  "><a href="/cats-effect/datatypes/" title="Data Types" class="drop-nested">Data Types</a><i class="fa fa-angle-right"></i><div class="sub-section"> <a href="/cats-effect/datatypes/io.html" title="IO" class="">IO</a> <a href="/cats-effect/datatypes/syncio.html" title="SyncIO" class="">SyncIO</a> <a href="/cats-effect/datatypes/fiber.html" title="Fiber" class="">Fiber</a> <a href="/cats-effect/datatypes/resource.html" title="Resource" class="">Resource</a> <a href="/cats-effect/datatypes/clock.html" title="Clock" class="">Clock</a> <a href="/cats-effect/datatypes/contextshift.html" title="ContextShift" class="">ContextShift</a> <a href="/cats-effect/datatypes/timer.html" title="Timer" class="">Timer</a> <a href="/cats-effect/datatypes/ioapp.html" title="IOApp" class="">IOApp</a></div></div> <div class="sidebar-nav-item  "><a href="/cats-effect/concurrency/" title="Concurrency" class="drop-nested">Concurrency</a><i class="fa fa-angle-right"></i><div class="sub-section"> <a href="/cats-effect/concurrency/basics.html" title="Concurrency Basics" class="">Concurrency Basics</a> <a href="/cats-effect/concurrency/deferred.html" title="Deferred" class="">Deferred</a> <a href="/cats-effect/concurrency/mvar.html" title="MVar" class="">MVar</a> <a href="/cats-effect/concurrency/ref.html" title="Ref" class="">Ref</a> <a href="/cats-effect/concurrency/semaphore.html" title="Semaphore" class="">Semaphore</a></div></div> <div class="sidebar-nav-item  "><a href="/cats-effect/typeclasses/" title="Type Classes" class="drop-nested">Type Classes</a><i class="fa fa-angle-right"></i><div class="sub-section"> <a href="/cats-effect/typeclasses/bracket.html" title="Bracket" class="">Bracket</a> <a href="/cats-effect/typeclasses/sync.html" title="Sync" class="">Sync</a> <a href="/cats-effect/typeclasses/liftio.html" title="LiftIO" class="">LiftIO</a> <a href="/cats-effect/typeclasses/async.html" title="Async" class="">Async</a> <a href="/cats-effect/typeclasses/concurrent.html" title="Concurrent" class="">Concurrent</a> <a href="/cats-effect/typeclasses/effect.html" title="Effect" class="">Effect</a> <a href="/cats-effect/typeclasses/concurrent-effect.html" title="ConcurrentEffect" class="">ConcurrentEffect</a></div></div> <div class="sidebar-nav-item active "><a href="/cats-effect/tutorial/tutorial.html" title="Tutorial" class="active">Tutorial</a></div> <div class="sidebar-nav-item  "><a href="/cats-effect/tracing/" title="Tracing" class="">Tracing</a></div></div></div><div id="page-content-wrapper"><div class="nav"><div class="container-fluid"><div class="row"><div class="col-lg-12"><div class="action-menu pull-left clearfix"><a href="#menu-toggle" id="menu-toggle"><i class="fa fa-bars" aria-hidden="true"></i></a></div><ul class="pull-right"><li id="gh-eyes-item" class="hidden-xs"><a href="https://github.com/typelevel/cats-effect" target="_blank" rel="noopener noreferrer"><i class="fa fa-eye"></i><span>Watchers<span id="eyes" class="label label-default">--</span></span></a></li><li id="gh-stars-item" class="hidden-xs"><a href="https://github.com/typelevel/cats-effect" target="_blank" rel="noopener noreferrer"><i class="fa fa-star-o"></i><span>Stars<span id="stars" class="label label-default">--</span></span></a></li></ul></div></div></div></div><div id="content" data-github-owner="typelevel" data-github-repo="cats-effect"><div class="content-wrapper"><section><h1>Tutorial</h1>

<nav role="navigation" id="toc"></nav>

<h2 id="introduction">Introduction</h2>

<p>This tutorial tries to help newcomers to cats-effect to get familiar with its
main concepts by means of code examples, in a learn-by-doing fashion. Two small
programs will be coded. The first one copies the contents from one file to
another, safely handling <em>resources</em> and <em>cancellation</em> in the process. That
should help us to flex our muscles. The second one implements a solution to the
producer-consumer problem to introduce cats-effect <em>fibers</em>.</p>

<p>This tutorial assumes certain familiarity with functional programming. It is
also a good idea to read cats-effect documentation prior to starting this
tutorial, at least the <a href="../datatypes/io.md">excellent documentation about <code class="highlighter-rouge">IO</code> data
type</a>.</p>

<p>Please read this tutorial as training material, not as a best-practices
document. As you gain more experience with cats-effect, probably you will find
your own solutions to deal with the problems presented here. Also, bear in mind
that using cats-effect for copying files or implementing basic concurrency
patterns (such as the producer-consumer problem) is suitable for a ‘getting
things done’ approach, but for more complex systems/settings/requirements you
might want to take a look at <a href="http://fs2.io">fs2</a> or <a href="https://monix.io">Monix</a>
to find powerful network and file abstractions that integrate with cats-effect.
But that is beyond the purpose of this tutorial, which focuses solely on
cats-effect.</p>

<p>That said, let’s go!</p>

<h2 id="setting-things-up">Setting things up</h2>

<p>This <a href="https://github.com/lrodero/cats-effect-tutorial">Github repo</a> includes all
the software that will be developed during this tutorial. It uses <code class="highlighter-rouge">sbt</code> as the
build tool. To ease coding, compiling and running the code snippets in this
tutorial it is recommended to use the same <code class="highlighter-rouge">build.sbt</code>, or at least one with the
same dependencies and compilation options:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">name</span> <span class="o">:=</span> <span class="s">"cats-effect-tutorial"</span>

<span class="n">version</span> <span class="o">:=</span> <span class="s">"2.1.4"</span>

<span class="n">scalaVersion</span> <span class="o">:=</span> <span class="s">"2.12.8"</span>

<span class="n">libraryDependencies</span> <span class="o">+=</span> <span class="s">"org.typelevel"</span> <span class="o">%%</span> <span class="s">"cats-effect"</span> <span class="o">%</span> <span class="s">"2.1.4"</span> <span class="n">withSources</span><span class="o">()</span> <span class="n">withJavadoc</span><span class="o">()</span>

<span class="n">scalacOptions</span> <span class="o">++=</span> <span class="nc">Seq</span><span class="o">(</span>
  <span class="s">"-feature"</span><span class="o">,</span>
  <span class="s">"-deprecation"</span><span class="o">,</span>
  <span class="s">"-unchecked"</span><span class="o">,</span>
  <span class="s">"-language:postfixOps"</span><span class="o">,</span>
  <span class="s">"-language:higherKinds"</span><span class="o">,</span>
  <span class="s">"-Ypartial-unification"</span><span class="o">)</span>
</code></pre></div></div>

<p>Code snippets in this tutorial can be pasted and compiled right in the scala
console of the project defined above (or any project with similar settings).</p>

<h2 id="copying-files---basic-concepts-resource-handling-and-cancellation">Copying files - basic concepts, resource handling and cancellation</h2>

<p>Our goal is to create a program that copies files. First we will work on a
function that carries such task, and then we will create a program that can be
invoked from the shell and uses that function.</p>

<p>First of all we must code the function that copies the content from a file to
another file. The function takes the source and destination files as parameters.
But this is functional programming! So invoking the function shall not copy
anything, instead it will return an <code class="highlighter-rouge">IO</code> instance that encapsulates all the
side effects involved (opening/closing files, reading/writing content), that way
<em>purity</em> is kept.  Only when that <code class="highlighter-rouge">IO</code> instance is evaluated all those
side-effectful actions will be run. In our implementation the <code class="highlighter-rouge">IO</code> instance will
return the amount of bytes copied upon execution, but this is just a design
decision. Of course errors can occur, but when working with any <code class="highlighter-rouge">IO</code> those
should be embedded in the <code class="highlighter-rouge">IO</code> instance. That is, no exception is raised outside
the <code class="highlighter-rouge">IO</code> and so no <code class="highlighter-rouge">try</code> (or the like) needs to be used when using the function,
instead the <code class="highlighter-rouge">IO</code> evaluation will fail and the <code class="highlighter-rouge">IO</code> instance will carry the error
raised.</p>

<p>Now, the signature of our function looks like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.IO</span>
<span class="k">import</span> <span class="nn">java.io.File</span>

<span class="k">def</span> <span class="n">copy</span><span class="o">(</span><span class="n">origin</span><span class="k">:</span> <span class="kt">File</span><span class="o">,</span> <span class="n">destination</span><span class="k">:</span> <span class="kt">File</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
</code></pre></div></div>

<p>Nothing scary, uh? As we said before, the function just returns an <code class="highlighter-rouge">IO</code>
instance. When run, all side-effects will be actually executed and the <code class="highlighter-rouge">IO</code>
instance will return the bytes copied in a <code class="highlighter-rouge">Long</code> (note that <code class="highlighter-rouge">IO</code> is
parameterized by the return type). Now, let’s start implementing our function.
First, we need to open two streams that will read and write file contents.</p>

<h3 id="acquiring-and-releasing-resources">Acquiring and releasing <code class="highlighter-rouge">Resource</code>s</h3>
<p>We consider opening a stream to be a side-effect action, so we have to
encapsulate those actions in their own <code class="highlighter-rouge">IO</code> instances. For this, we will make
use of cats-effect <code class="highlighter-rouge">Resource</code>, that allows to orderly create, use and then
release resources. See this code:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.</span><span class="o">{</span><span class="nc">IO</span><span class="o">,</span> <span class="nc">Resource</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">cats.implicits._</span> 
<span class="k">import</span> <span class="nn">java.io._</span> 

<span class="k">def</span> <span class="n">inputStream</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">File</span><span class="o">)</span><span class="k">:</span> <span class="kt">Resource</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">FileInputStream</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">Resource</span><span class="o">.</span><span class="n">make</span> <span class="o">{</span>
    <span class="nc">IO</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="n">f</span><span class="o">))</span>                         <span class="c1">// build
</span>  <span class="o">}</span> <span class="o">{</span> <span class="n">inStream</span> <span class="k">=&gt;</span>
    <span class="nc">IO</span><span class="o">(</span><span class="n">inStream</span><span class="o">.</span><span class="n">close</span><span class="o">()).</span><span class="n">handleErrorWith</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">IO</span><span class="o">.</span><span class="n">unit</span><span class="o">)</span> <span class="c1">// release
</span>  <span class="o">}</span>

<span class="k">def</span> <span class="n">outputStream</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">File</span><span class="o">)</span><span class="k">:</span> <span class="kt">Resource</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">FileOutputStream</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">Resource</span><span class="o">.</span><span class="n">make</span> <span class="o">{</span>
    <span class="nc">IO</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="n">f</span><span class="o">))</span>                         <span class="c1">// build 
</span>  <span class="o">}</span> <span class="o">{</span> <span class="n">outStream</span> <span class="k">=&gt;</span>
    <span class="nc">IO</span><span class="o">(</span><span class="n">outStream</span><span class="o">.</span><span class="n">close</span><span class="o">()).</span><span class="n">handleErrorWith</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">IO</span><span class="o">.</span><span class="n">unit</span><span class="o">)</span> <span class="c1">// release
</span>  <span class="o">}</span>

<span class="k">def</span> <span class="n">inputOutputStreams</span><span class="o">(</span><span class="n">in</span><span class="k">:</span> <span class="kt">File</span><span class="o">,</span> <span class="n">out</span><span class="k">:</span> <span class="kt">File</span><span class="o">)</span><span class="k">:</span> <span class="kt">Resource</span><span class="o">[</span><span class="kt">IO</span>, <span class="o">(</span><span class="kt">InputStream</span>, <span class="kt">OutputStream</span><span class="o">)]</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="n">inStream</span>  <span class="k">&lt;-</span> <span class="n">inputStream</span><span class="o">(</span><span class="n">in</span><span class="o">)</span>
    <span class="n">outStream</span> <span class="k">&lt;-</span> <span class="n">outputStream</span><span class="o">(</span><span class="n">out</span><span class="o">)</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="o">(</span><span class="n">inStream</span><span class="o">,</span> <span class="n">outStream</span><span class="o">)</span>
</code></pre></div></div>

<p>We want to ensure that streams are closed once we are done using them, no matter
what. That is precisely why we use <code class="highlighter-rouge">Resource</code> in both <code class="highlighter-rouge">inputStream</code> and
<code class="highlighter-rouge">outputStream</code> functions, each one returning one <code class="highlighter-rouge">Resource</code> that encapsulates
the actions for opening and then closing each stream.  <code class="highlighter-rouge">inputOutputStreams</code>
encapsulates both resources in a single <code class="highlighter-rouge">Resource</code> instance that will be
available once the creation of both streams has been successful, and only in
that case. As seen in the code above <code class="highlighter-rouge">Resource</code> instances can be combined in
for-comprehensions as they implement <code class="highlighter-rouge">flatMap</code>. Note also that when releasing
resources we must also take care of any possible error during the release
itself, for example with the <code class="highlighter-rouge">.handleErrorWith</code> call as we do in the code above.
In this case we just swallow the error, but normally it should be at least
logged.</p>

<p>Optionally we could have used <code class="highlighter-rouge">Resource.fromAutoCloseable</code> to define our
resources, that method creates <code class="highlighter-rouge">Resource</code> instances over objects that implement
<code class="highlighter-rouge">java.lang.AutoCloseable</code> interface without having to define how the resource is
released. So our <code class="highlighter-rouge">inputStream</code> function would look like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.</span><span class="o">{</span><span class="nc">IO</span><span class="o">,</span> <span class="nc">Resource</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">java.io.</span><span class="o">{</span><span class="nc">File</span><span class="o">,</span> <span class="nc">FileInputStream</span><span class="o">}</span>

<span class="k">def</span> <span class="n">inputStream</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">File</span><span class="o">)</span><span class="k">:</span> <span class="kt">Resource</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">FileInputStream</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">Resource</span><span class="o">.</span><span class="n">fromAutoCloseable</span><span class="o">(</span><span class="nc">IO</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="n">f</span><span class="o">)))</span>
</code></pre></div></div>

<p>That code is way simpler, but with that code we would not have control over what
would happen if the closing operation throws an exception. Also it could be that
we want to be aware when closing operations are being run, for example using
logs. In contrast, using <code class="highlighter-rouge">Resource.make</code> allows to easily control the actions
of the release phase.</p>

<p>Let’s go back to our <code class="highlighter-rouge">copy</code> function, which now looks like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.</span><span class="o">{</span><span class="nc">IO</span><span class="o">,</span> <span class="nc">Resource</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">java.io._</span>

<span class="c1">// as defined before
</span><span class="k">def</span> <span class="n">inputOutputStreams</span><span class="o">(</span><span class="n">in</span><span class="k">:</span> <span class="kt">File</span><span class="o">,</span> <span class="n">out</span><span class="k">:</span> <span class="kt">File</span><span class="o">)</span><span class="k">:</span> <span class="kt">Resource</span><span class="o">[</span><span class="kt">IO</span>, <span class="o">(</span><span class="kt">InputStream</span>, <span class="kt">OutputStream</span><span class="o">)]</span> <span class="k">=</span> <span class="o">???</span>

<span class="c1">// transfer will do the real work
</span><span class="k">def</span> <span class="n">transfer</span><span class="o">(</span><span class="n">origin</span><span class="k">:</span> <span class="kt">InputStream</span><span class="o">,</span> <span class="n">destination</span><span class="k">:</span> <span class="kt">OutputStream</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>

<span class="k">def</span> <span class="n">copy</span><span class="o">(</span><span class="n">origin</span><span class="k">:</span> <span class="kt">File</span><span class="o">,</span> <span class="n">destination</span><span class="k">:</span> <span class="kt">File</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="k">=</span> 
  <span class="n">inputOutputStreams</span><span class="o">(</span><span class="n">origin</span><span class="o">,</span> <span class="n">destination</span><span class="o">).</span><span class="n">use</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">in</span><span class="o">,</span> <span class="n">out</span><span class="o">)</span> <span class="k">=&gt;</span> 
    <span class="n">transfer</span><span class="o">(</span><span class="n">in</span><span class="o">,</span> <span class="n">out</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>The new method <code class="highlighter-rouge">transfer</code> will perform the actual copying of data, once the
resources (the streams) are obtained. When they are not needed anymore, whatever
the outcome of <code class="highlighter-rouge">transfer</code> (success or failure) both streams will be closed. If
any of the streams could not be obtained, then <code class="highlighter-rouge">transfer</code> will not be run. Even
better, because of <code class="highlighter-rouge">Resource</code> semantics, if there is any problem opening the
input file then the output file will not be opened.  On the other hand, if there
is any issue opening the output file, then the input stream will be closed.</p>

<h3 id="what-about-bracket">What about <code class="highlighter-rouge">bracket</code>?</h3>
<p>Now, if you are familiar with cats-effect’s <code class="highlighter-rouge">bracket</code> you may be wondering why
we are not using it as it looks so similar to <code class="highlighter-rouge">Resource</code> (and there is a good
reason for that: <code class="highlighter-rouge">Resource</code> is based on <code class="highlighter-rouge">bracket</code>). Ok, before moving forward it
is worth to take a look to <code class="highlighter-rouge">bracket</code>.</p>

<p>There are three stages when using <code class="highlighter-rouge">bracket</code>: <em>resource acquisition</em>, <em>usage</em>,
and <em>release</em>. Each stage is defined by an <code class="highlighter-rouge">IO</code> instance.  A fundamental
property is that the <em>release</em> stage will always be run regardless whether the
<em>usage</em> stage finished correctly or an exception was thrown during its
execution. In our case, in the <em>acquisition</em> stage we would create the streams,
then in the <em>usage</em> stage we will copy the contents, and finally in the release
stage we will close the streams.  Thus we could define our <code class="highlighter-rouge">copy</code> function as
follows:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.IO</span>
<span class="k">import</span> <span class="nn">cats.implicits._</span> 
<span class="k">import</span> <span class="nn">java.io._</span> 

<span class="c1">// function inputOutputStreams not needed
</span>
<span class="c1">// transfer will do the real work
</span><span class="k">def</span> <span class="n">transfer</span><span class="o">(</span><span class="n">origin</span><span class="k">:</span> <span class="kt">InputStream</span><span class="o">,</span> <span class="n">destination</span><span class="k">:</span> <span class="kt">OutputStream</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>

<span class="k">def</span> <span class="n">copy</span><span class="o">(</span><span class="n">origin</span><span class="k">:</span> <span class="kt">File</span><span class="o">,</span> <span class="n">destination</span><span class="k">:</span> <span class="kt">File</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">inIO</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">InputStream</span><span class="o">]</span>  <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="n">origin</span><span class="o">))</span>
  <span class="k">val</span> <span class="n">outIO</span><span class="k">:</span><span class="kt">IO</span><span class="o">[</span><span class="kt">OutputStream</span><span class="o">]</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="n">destination</span><span class="o">))</span>

  <span class="o">(</span><span class="n">inIO</span><span class="o">,</span> <span class="n">outIO</span><span class="o">)</span>              <span class="c1">// Stage 1: Getting resources 
</span>    <span class="o">.</span><span class="n">tupled</span>                  <span class="c1">// From (IO[InputStream], IO[OutputStream]) to IO[(InputStream, OutputStream)]
</span>    <span class="o">.</span><span class="n">bracket</span><span class="o">{</span>
      <span class="k">case</span> <span class="o">(</span><span class="n">in</span><span class="o">,</span> <span class="n">out</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="n">transfer</span><span class="o">(</span><span class="n">in</span><span class="o">,</span> <span class="n">out</span><span class="o">)</span>    <span class="c1">// Stage 2: Using resources (for copying data, in this case)
</span>    <span class="o">}</span> <span class="o">{</span>
      <span class="k">case</span> <span class="o">(</span><span class="n">in</span><span class="o">,</span> <span class="n">out</span><span class="o">)</span> <span class="k">=&gt;</span>      <span class="c1">// Stage 3: Freeing resources
</span>        <span class="o">(</span><span class="nc">IO</span><span class="o">(</span><span class="n">in</span><span class="o">.</span><span class="n">close</span><span class="o">()),</span> <span class="nc">IO</span><span class="o">(</span><span class="n">out</span><span class="o">.</span><span class="n">close</span><span class="o">()))</span>
        <span class="o">.</span><span class="n">tupled</span>              <span class="c1">// From (IO[Unit], IO[Unit]) to IO[(Unit, Unit)]
</span>        <span class="o">.</span><span class="n">handleErrorWith</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">IO</span><span class="o">.</span><span class="n">unit</span><span class="o">).</span><span class="n">void</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>New <code class="highlighter-rouge">copy</code> definition is more complex, even though the code as a whole is way
shorter as we do not need the <code class="highlighter-rouge">inputOutputStreams</code> function. But there is a
catch in the code above.  When using <code class="highlighter-rouge">bracket</code>, if there is a problem when
getting resources in the first stage, then the release stage will not be run.
Now, in the code above, first the origin file and then the destination file are
opened (<code class="highlighter-rouge">tupled</code> just reorganizes both <code class="highlighter-rouge">IO</code> instances into a single one). So
what would happen if we successfully open the origin file (<em>i.e.</em> when
evaluating <code class="highlighter-rouge">inIO</code>) but then an exception is raised when opening the destination
file (<em>i.e.</em> when evaluating <code class="highlighter-rouge">outIO</code>)? In that case the origin stream will not
be closed! To solve this we should first get the first stream with one <code class="highlighter-rouge">bracket</code>
call, and then the second stream with another <code class="highlighter-rouge">bracket</code> call inside the first.
But, in a way, that’s precisely what we do when we <code class="highlighter-rouge">flatMap</code> instances of
<code class="highlighter-rouge">Resource</code>. And the code looks cleaner too. So, while using <code class="highlighter-rouge">bracket</code> directly
has its place, <code class="highlighter-rouge">Resource</code> is likely to be a better choice when dealing with
multiple resources at once.</p>

<h3 id="copying-data">Copying data</h3>
<p>Finally we have our streams ready to go! We have to focus now on coding
<code class="highlighter-rouge">transfer</code>. That function will have to define a loop that at each iteration
reads data from the input stream into a buffer, and then writes the buffer
contents into the output stream. At the same time, the loop will keep a counter
of the bytes transferred. To reuse the same buffer we should define it outside
the main loop, and leave the actual transmission of data to another function
<code class="highlighter-rouge">transmit</code> that uses that loop. Something like:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.IO</span>
<span class="k">import</span> <span class="nn">cats.implicits._</span> 
<span class="k">import</span> <span class="nn">java.io._</span> 

<span class="k">def</span> <span class="n">transmit</span><span class="o">(</span><span class="n">origin</span><span class="k">:</span> <span class="kt">InputStream</span><span class="o">,</span> <span class="n">destination</span><span class="k">:</span> <span class="kt">OutputStream</span><span class="o">,</span> <span class="n">buffer</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">],</span> <span class="n">acc</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="n">amount</span> <span class="k">&lt;-</span> <span class="nc">IO</span><span class="o">(</span><span class="n">origin</span><span class="o">.</span><span class="n">read</span><span class="o">(</span><span class="n">buffer</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">buffer</span><span class="o">.</span><span class="n">size</span><span class="o">))</span>
    <span class="n">count</span>  <span class="k">&lt;-</span> <span class="k">if</span><span class="o">(</span><span class="n">amount</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="nc">IO</span><span class="o">(</span><span class="n">destination</span><span class="o">.</span><span class="n">write</span><span class="o">(</span><span class="n">buffer</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">amount</span><span class="o">))</span> <span class="o">&gt;&gt;</span> <span class="n">transmit</span><span class="o">(</span><span class="n">origin</span><span class="o">,</span> <span class="n">destination</span><span class="o">,</span> <span class="n">buffer</span><span class="o">,</span> <span class="n">acc</span> <span class="o">+</span> <span class="n">amount</span><span class="o">)</span>
              <span class="k">else</span> <span class="nc">IO</span><span class="o">.</span><span class="n">pure</span><span class="o">(</span><span class="n">acc</span><span class="o">)</span> <span class="c1">// End of read stream reached (by java.io.InputStream contract), nothing to write
</span>  <span class="o">}</span> <span class="k">yield</span> <span class="n">count</span> <span class="c1">// Returns the actual amount of bytes transmitted
</span>
<span class="k">def</span> <span class="n">transfer</span><span class="o">(</span><span class="n">origin</span><span class="k">:</span> <span class="kt">InputStream</span><span class="o">,</span> <span class="n">destination</span><span class="k">:</span> <span class="kt">OutputStream</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="n">buffer</span> <span class="k">&lt;-</span> <span class="nc">IO</span><span class="o">(</span><span class="k">new</span> <span class="nc">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">](</span><span class="mi">1024</span> <span class="o">*</span> <span class="mi">10</span><span class="o">))</span> <span class="c1">// Allocated only when the IO is evaluated
</span>    <span class="n">total</span>  <span class="k">&lt;-</span> <span class="n">transmit</span><span class="o">(</span><span class="n">origin</span><span class="o">,</span> <span class="n">destination</span><span class="o">,</span> <span class="n">buffer</span><span class="o">,</span> <span class="mi">0L</span><span class="o">)</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">total</span>
</code></pre></div></div>

<p>Take a look at <code class="highlighter-rouge">transmit</code>, observe that both input and output actions are
encapsulated in (suspended in) <code class="highlighter-rouge">IO</code>. <code class="highlighter-rouge">IO</code> being a monad, we can sequence them
using a for-comprehension to create another <code class="highlighter-rouge">IO</code>. The for-comprehension loops as
long as the call to <code class="highlighter-rouge">read()</code> does not return a negative value that would signal
that the end of the stream has been reached. <code class="highlighter-rouge">&gt;&gt;</code> is a Cats operator to sequence
two operations where the output of the first is not needed by the second (<em>i.e.</em>
it is equivalent to <code class="highlighter-rouge">first.flatMap(_ =&gt; second)</code>). In the code above that means
that after each write operation we recursively call <code class="highlighter-rouge">transmit</code> again, but as
<code class="highlighter-rouge">IO</code> is stack safe we are not concerned about stack overflow issues. At each
iteration we increase the counter <code class="highlighter-rouge">acc</code> with the amount of bytes read at that
iteration.</p>

<p>We are making progress, and already have a version of <code class="highlighter-rouge">copy</code> that can be used.
If any exception is raised when <code class="highlighter-rouge">transfer</code> is running, then the streams will be
automatically closed by <code class="highlighter-rouge">Resource</code>. But there is something else we have to take
into account: <code class="highlighter-rouge">IO</code> instances execution can be <strong><em>canceled!</em></strong>. And cancellation
should not be ignored, as it is a key feature of cats-effect. We will discuss
cancellation in the next section.</p>

<h3 id="dealing-with-cancellation">Dealing with cancellation</h3>
<p>Cancellation is a powerful but non-trivial cats-effect feature. In cats-effect,
some <code class="highlighter-rouge">IO</code> instances can be canceled ( <em>e.g.</em> by other <code class="highlighter-rouge">IO</code> instaces running
concurrently) meaning that their evalation will be aborted. If the programmer is
careful, an alternative <code class="highlighter-rouge">IO</code> task will be run under cancellation, for example to
deal with potential cleaning up activities.</p>

<p>Now, <code class="highlighter-rouge">IO</code>s created with <code class="highlighter-rouge">Resource.use</code> can be canceled. The cancellation will
trigger the execution of the code that handles the closing of the resource. In
our case, that would close both streams. So far so good! But what happens if
cancellation happens <em>while</em> the streams are being used? This could lead to data
corruption as a stream where some thread is writing to is at the same time being
closed by another thread. For more info about this problem see <a href="../datatypes/io.html#gotcha-cancellation-is-a-concurrent-action">Gotcha:
Cancellation is a concurrent
action</a> in
cats-effect site.</p>

<p>To prevent such data corruption we must use some concurrency control mechanism
that ensures that no stream will be closed while the <code class="highlighter-rouge">IO</code> returned by <code class="highlighter-rouge">transfer</code>
is being evaluated.  Cats-effect provides several constructs for controlling
concurrency, for this case we will use a
<a href="/cats-effect/concurrency/semaphore.html"><em>semaphore</em></a>. A semaphore has a number of permits,
its method <code class="highlighter-rouge">.acquire</code> ‘blocks’ if no permit is available until <code class="highlighter-rouge">release</code> is
called on the same semaphore. It is important to remark that <em>there is no actual
thread being really blocked</em>, the thread that finds the <code class="highlighter-rouge">.acquire</code> call will be
immediately recycled by cats-effect. When the <code class="highlighter-rouge">release</code> method is invoked then
cats-effect will look for some available thread to resume the execution of the
code after <code class="highlighter-rouge">.acquire</code>.</p>

<p>We will use a semaphore with a single permit. The <code class="highlighter-rouge">.withPermit</code> method acquires
one permit, runs the <code class="highlighter-rouge">IO</code> given and then releases the permit.  We could also
use <code class="highlighter-rouge">.acquire</code> and then <code class="highlighter-rouge">.release</code> on the semaphore explicitly, but
<code class="highlighter-rouge">.withPermit</code> is more idiomatic and ensures that the permit is released even if
the effect run fails.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.implicits._</span>
<span class="k">import</span> <span class="nn">cats.effect.</span><span class="o">{</span><span class="nc">Concurrent</span><span class="o">,</span> <span class="nc">IO</span><span class="o">,</span> <span class="nc">Resource</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">cats.effect.concurrent.Semaphore</span>
<span class="k">import</span> <span class="nn">java.io._</span>

<span class="c1">// transfer and transmit methods as defined before
</span><span class="k">def</span> <span class="n">transfer</span><span class="o">(</span><span class="n">origin</span><span class="k">:</span> <span class="kt">InputStream</span><span class="o">,</span> <span class="n">destination</span><span class="k">:</span> <span class="kt">OutputStream</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>

<span class="k">def</span> <span class="n">inputStream</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">File</span><span class="o">,</span> <span class="n">guard</span><span class="k">:</span> <span class="kt">Semaphore</span><span class="o">[</span><span class="kt">IO</span><span class="o">])</span><span class="k">:</span> <span class="kt">Resource</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">FileInputStream</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">Resource</span><span class="o">.</span><span class="n">make</span> <span class="o">{</span>
    <span class="nc">IO</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="n">f</span><span class="o">))</span>
  <span class="o">}</span> <span class="o">{</span> <span class="n">inStream</span> <span class="k">=&gt;</span> 
    <span class="n">guard</span><span class="o">.</span><span class="n">withPermit</span> <span class="o">{</span>
     <span class="nc">IO</span><span class="o">(</span><span class="n">inStream</span><span class="o">.</span><span class="n">close</span><span class="o">()).</span><span class="n">handleErrorWith</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">IO</span><span class="o">.</span><span class="n">unit</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>

<span class="k">def</span> <span class="n">outputStream</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">File</span><span class="o">,</span> <span class="n">guard</span><span class="k">:</span> <span class="kt">Semaphore</span><span class="o">[</span><span class="kt">IO</span><span class="o">])</span><span class="k">:</span> <span class="kt">Resource</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">FileOutputStream</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">Resource</span><span class="o">.</span><span class="n">make</span> <span class="o">{</span>
    <span class="nc">IO</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="n">f</span><span class="o">))</span>
  <span class="o">}</span> <span class="o">{</span> <span class="n">outStream</span> <span class="k">=&gt;</span>
    <span class="n">guard</span><span class="o">.</span><span class="n">withPermit</span> <span class="o">{</span>
     <span class="nc">IO</span><span class="o">(</span><span class="n">outStream</span><span class="o">.</span><span class="n">close</span><span class="o">()).</span><span class="n">handleErrorWith</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">IO</span><span class="o">.</span><span class="n">unit</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>

<span class="k">def</span> <span class="n">inputOutputStreams</span><span class="o">(</span><span class="n">in</span><span class="k">:</span> <span class="kt">File</span><span class="o">,</span> <span class="n">out</span><span class="k">:</span> <span class="kt">File</span><span class="o">,</span> <span class="n">guard</span><span class="k">:</span> <span class="kt">Semaphore</span><span class="o">[</span><span class="kt">IO</span><span class="o">])</span><span class="k">:</span> <span class="kt">Resource</span><span class="o">[</span><span class="kt">IO</span>, <span class="o">(</span><span class="kt">InputStream</span>, <span class="kt">OutputStream</span><span class="o">)]</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="n">inStream</span>  <span class="k">&lt;-</span> <span class="n">inputStream</span><span class="o">(</span><span class="n">in</span><span class="o">,</span> <span class="n">guard</span><span class="o">)</span>
    <span class="n">outStream</span> <span class="k">&lt;-</span> <span class="n">outputStream</span><span class="o">(</span><span class="n">out</span><span class="o">,</span> <span class="n">guard</span><span class="o">)</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="o">(</span><span class="n">inStream</span><span class="o">,</span> <span class="n">outStream</span><span class="o">)</span>

<span class="k">def</span> <span class="n">copy</span><span class="o">(</span><span class="n">origin</span><span class="k">:</span> <span class="kt">File</span><span class="o">,</span> <span class="n">destination</span><span class="k">:</span> <span class="kt">File</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">concurrent</span><span class="k">:</span> <span class="kt">Concurrent</span><span class="o">[</span><span class="kt">IO</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="n">guard</span> <span class="k">&lt;-</span> <span class="nc">Semaphore</span><span class="o">[</span><span class="kt">IO</span><span class="o">](</span><span class="mi">1</span><span class="o">)</span>
    <span class="n">count</span> <span class="k">&lt;-</span> <span class="n">inputOutputStreams</span><span class="o">(</span><span class="n">origin</span><span class="o">,</span> <span class="n">destination</span><span class="o">,</span> <span class="n">guard</span><span class="o">).</span><span class="n">use</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">in</span><span class="o">,</span> <span class="n">out</span><span class="o">)</span> <span class="k">=&gt;</span> 
               <span class="n">guard</span><span class="o">.</span><span class="n">withPermit</span><span class="o">(</span><span class="n">transfer</span><span class="o">(</span><span class="n">in</span><span class="o">,</span> <span class="n">out</span><span class="o">))</span>
             <span class="o">}</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">count</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Before calling to <code class="highlighter-rouge">transfer</code> we acquire the semaphore, which is not released
until <code class="highlighter-rouge">transfer</code> is done. The <code class="highlighter-rouge">use</code> call ensures that the semaphore will be
released under any circumstances, whatever the result of <code class="highlighter-rouge">transfer</code> (success,
error, or cancellation). As the ‘release’ parts in the <code class="highlighter-rouge">Resource</code> instances are
now blocked on the same semaphore, we can be sure that streams are closed only
after <code class="highlighter-rouge">transfer</code> is over, <em>i.e.</em> we have implemented mutual exclusion of
<code class="highlighter-rouge">transfer</code> execution and resources releasing. An implicit <code class="highlighter-rouge">Concurrent</code> instance
is required to create the semaphore instance, which is included in the function
signature.</p>

<p>Mark that while the <code class="highlighter-rouge">IO</code> returned by <code class="highlighter-rouge">copy</code> is cancelable (because so are <code class="highlighter-rouge">IO</code>
instances returned by <code class="highlighter-rouge">Resource.use</code>), the <code class="highlighter-rouge">IO</code> returned by <code class="highlighter-rouge">transfer</code> is not.
Trying to cancel it will not have any effect and that <code class="highlighter-rouge">IO</code> will run until the
whole file is copied! In real world code you will probably want to make your
functions cancelable, section <a href="../datatypes/io.html#building-cancelable-io-tasks">Building cancelable IO
tasks</a> of <code class="highlighter-rouge">IO</code> documentation
explains how to create such cancelable <code class="highlighter-rouge">IO</code> instances (besides calling
<code class="highlighter-rouge">Resource.use</code>, as we have done for our code).</p>

<p>And that is it! We are done, now we can create a program that uses this
<code class="highlighter-rouge">copy</code> function.</p>

<h3 id="ioapp-for-our-final-program"><code class="highlighter-rouge">IOApp</code> for our final program</h3>

<p>We will create a program that copies files, this program only takes two
parameters: the name of the origin and destination files. For coding this
program we will use <code class="highlighter-rouge">IOApp</code> as it allows to maintain purity in our definitions
up to the program main function.</p>

<p><code class="highlighter-rouge">IOApp</code> is a kind of ‘functional’ equivalent to Scala’s <code class="highlighter-rouge">App</code>, where instead of
coding an effectful <code class="highlighter-rouge">main</code> method we code a pure <code class="highlighter-rouge">run</code> function. When executing
the class a <code class="highlighter-rouge">main</code> method defined in <code class="highlighter-rouge">IOApp</code> will call the <code class="highlighter-rouge">run</code> function we
have coded. Any interruption (like pressing <code class="highlighter-rouge">Ctrl-c</code>) will be treated as a
cancellation of the running <code class="highlighter-rouge">IO</code>. Also <code class="highlighter-rouge">IOApp</code> provides implicit instances of
<code class="highlighter-rouge">Timer[IO]</code> and <code class="highlighter-rouge">ContextShift[IO]</code> (not discussed yet in this tutorial).
<code class="highlighter-rouge">ContextShift[IO]</code> allows for having a <code class="highlighter-rouge">Concurrent[IO]</code> in scope, as the one
required by the <code class="highlighter-rouge">copy</code> function.</p>

<p>When coding <code class="highlighter-rouge">IOApp</code>, instead of a <code class="highlighter-rouge">main</code> function we have a <code class="highlighter-rouge">run</code> function,
which creates the <code class="highlighter-rouge">IO</code> instance that forms the program. In our case, our <code class="highlighter-rouge">run</code>
method can look like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect._</span>
<span class="k">import</span> <span class="nn">cats.implicits._</span>
<span class="k">import</span> <span class="nn">java.io.File</span>

<span class="k">object</span> <span class="nc">Main</span> <span class="k">extends</span> <span class="nc">IOApp</span> <span class="o">{</span>

  <span class="c1">// copy as defined before
</span>  <span class="k">def</span> <span class="n">copy</span><span class="o">(</span><span class="n">origin</span><span class="k">:</span> <span class="kt">File</span><span class="o">,</span> <span class="n">destination</span><span class="k">:</span> <span class="kt">File</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">run</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">ExitCode</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">for</span> <span class="o">{</span>
      <span class="k">_</span>      <span class="k">&lt;-</span> <span class="k">if</span><span class="o">(</span><span class="n">args</span><span class="o">.</span><span class="n">length</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">)</span> <span class="nc">IO</span><span class="o">.</span><span class="n">raiseError</span><span class="o">(</span><span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">"Need origin and destination files"</span><span class="o">))</span>
                <span class="k">else</span> <span class="nc">IO</span><span class="o">.</span><span class="n">unit</span>
      <span class="n">orig</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="n">args</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span>
      <span class="n">dest</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="n">args</span><span class="o">(</span><span class="mi">1</span><span class="o">))</span>
      <span class="n">count</span> <span class="k">&lt;-</span> <span class="n">copy</span><span class="o">(</span><span class="n">orig</span><span class="o">,</span> <span class="n">dest</span><span class="o">)</span>
      <span class="k">_</span>     <span class="k">&lt;-</span> <span class="nc">IO</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"$count bytes copied from ${orig.getPath} to ${dest.getPath}"</span><span class="o">))</span>
    <span class="o">}</span> <span class="k">yield</span> <span class="nc">ExitCode</span><span class="o">.</span><span class="nc">Success</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Heed how <code class="highlighter-rouge">run</code> verifies the <code class="highlighter-rouge">args</code> list passed. If there are fewer than two
arguments, an error is raised. As <code class="highlighter-rouge">IO</code> implements <code class="highlighter-rouge">MonadError</code> we can at any
moment call to <code class="highlighter-rouge">IO.raiseError</code> to interrupt a sequence of <code class="highlighter-rouge">IO</code> operations.</p>

<h4 id="copy-program-code">Copy program code</h4>
<p>You can check the <a href="https://github.com/lrodero/cats-effect-tutorial/blob/replace_tcp_section_with_prodcons/src/main/scala/catsEffectTutorial/copyfile/CopyFile.scala">final version of our copy program
here</a>.</p>

<p>The program can be run from <code class="highlighter-rouge">sbt</code> just by issuing this call:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">runMain</span> <span class="n">catsEffectTutorial</span><span class="o">.</span><span class="nc">CopyFile</span> <span class="n">origin</span><span class="o">.</span><span class="n">txt</span> <span class="n">destination</span><span class="o">.</span><span class="n">txt</span>
</code></pre></div></div>

<p>It can be argued that using <code class="highlighter-rouge">IO{java.nio.file.Files.copy(...)}</code> would get an
<code class="highlighter-rouge">IO</code> with the same characteristics of purity as our function. But there is a
difference: our <code class="highlighter-rouge">IO</code> is safely cancelable! So the user can stop the running code
at any time for example by pressing <code class="highlighter-rouge">Ctrl-c</code>, our code will deal with safe
resource release (streams closing) even under such circumstances. The same will
apply if the <code class="highlighter-rouge">copy</code> function is run from other modules that require its
functionality. If the <code class="highlighter-rouge">IO</code> returned by this function is canceled while being
run, still resources will be properly released. But recall what we commented
before: this is because <code class="highlighter-rouge">use</code> returns <code class="highlighter-rouge">IO</code> instances that are cancelable, in
contrast our <code class="highlighter-rouge">transfer</code> function is not cancelable.</p>

<p>WARNING: To properly test cancelation, You should also ensure that
<code class="highlighter-rouge">fork := true</code> is set in the sbt configuration, otherwise sbt will
intercept the cancelation because it will be running the program
in the same JVM as itself.</p>

<h3 id="polymorphic-cats-effect-code">Polymorphic cats-effect code</h3>
<p>There is an important characteristic of <code class="highlighter-rouge">IO</code> that we shall be aware of. <code class="highlighter-rouge">IO</code> is
able to encapsulate side-effects, but the capacity to define concurrent and/or
async and/or cancelable <code class="highlighter-rouge">IO</code> instances comes from the existence of a
<code class="highlighter-rouge">Concurrent[IO]</code> instance. <code class="highlighter-rouge">Concurrent[F[_]]</code> is a type class that, for an <code class="highlighter-rouge">F</code>
carrying a side-effect, brings the ability to cancel or start concurrently the
side-effect in <code class="highlighter-rouge">F</code>. <code class="highlighter-rouge">Concurrent</code> also extends type class <code class="highlighter-rouge">Async[F[_]]</code>, that
allows to define synchronous/asynchronous computations. <code class="highlighter-rouge">Async[F[_]]</code>, in turn,
extends type class <code class="highlighter-rouge">Sync[F[_]]</code>, which can suspend the execution of side effects
in <code class="highlighter-rouge">F</code>.</p>

<p>So well, <code class="highlighter-rouge">Sync</code> can suspend side effects (and so can <code class="highlighter-rouge">Async</code> and <code class="highlighter-rouge">Concurrent</code> as
they extend <code class="highlighter-rouge">Sync</code>). We have used <code class="highlighter-rouge">IO</code> so far mostly for that purpose. Now,
going back to the code we created to copy files, could have we coded its
functions in terms of some <code class="highlighter-rouge">F[_]: Sync</code> instead of <code class="highlighter-rouge">IO</code>? Truth is we could and
<strong>in fact it is recommendable</strong> in real world programs.  See for example how we
would define a polymorphic version of our <code class="highlighter-rouge">transfer</code> function with this
approach, just by replacing any use of <code class="highlighter-rouge">IO</code> by calls to the <code class="highlighter-rouge">delay</code> and <code class="highlighter-rouge">pure</code>
methods of the <code class="highlighter-rouge">Sync[F[_]]</code> instance!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.Sync</span>
<span class="k">import</span> <span class="nn">cats.effect.syntax.all._</span>
<span class="k">import</span> <span class="nn">cats.implicits._</span>
<span class="k">import</span> <span class="nn">java.io._</span>

<span class="k">def</span> <span class="n">transmit</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Sync</span><span class="o">](</span><span class="n">origin</span><span class="k">:</span> <span class="kt">InputStream</span><span class="o">,</span> <span class="n">destination</span><span class="k">:</span> <span class="kt">OutputStream</span><span class="o">,</span> <span class="n">buffer</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">],</span> <span class="n">acc</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="n">amount</span> <span class="k">&lt;-</span> <span class="nc">Sync</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">delay</span><span class="o">(</span><span class="n">origin</span><span class="o">.</span><span class="n">read</span><span class="o">(</span><span class="n">buffer</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">buffer</span><span class="o">.</span><span class="n">size</span><span class="o">))</span>
    <span class="n">count</span>  <span class="k">&lt;-</span> <span class="k">if</span><span class="o">(</span><span class="n">amount</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="nc">Sync</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">delay</span><span class="o">(</span><span class="n">destination</span><span class="o">.</span><span class="n">write</span><span class="o">(</span><span class="n">buffer</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">amount</span><span class="o">))</span> <span class="o">&gt;&gt;</span> <span class="n">transmit</span><span class="o">(</span><span class="n">origin</span><span class="o">,</span> <span class="n">destination</span><span class="o">,</span> <span class="n">buffer</span><span class="o">,</span> <span class="n">acc</span> <span class="o">+</span> <span class="n">amount</span><span class="o">)</span>
              <span class="k">else</span> <span class="nc">Sync</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">pure</span><span class="o">(</span><span class="n">acc</span><span class="o">)</span> <span class="c1">// End of read stream reached (by java.io.InputStream contract), nothing to write
</span>  <span class="o">}</span> <span class="k">yield</span> <span class="n">count</span> <span class="c1">// Returns the actual amount of bytes transmitted
</span></code></pre></div></div>

<p>We leave as an exercise to code the polymorphic versions of <code class="highlighter-rouge">inputStream</code>,
<code class="highlighter-rouge">outputStream</code>, <code class="highlighter-rouge">inputOutputStreams</code> and <code class="highlighter-rouge">transfer</code> functions. You will
find that transformation similar to the one shown for <code class="highlighter-rouge">transfer</code> in the snippet
above. Function <code class="highlighter-rouge">copy</code> is different however. If you try to implement that
function as well you will realize that we need a full instance of
<code class="highlighter-rouge">Concurrent[F]</code> in scope, this is because it is required by the <code class="highlighter-rouge">Semaphore</code>
instantiation:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect._</span>
<span class="k">import</span> <span class="nn">cats.effect.concurrent.Semaphore</span>
<span class="k">import</span> <span class="nn">cats.effect.syntax.all._</span>
<span class="k">import</span> <span class="nn">cats.implicits._</span>
<span class="k">import</span> <span class="nn">java.io._</span>

<span class="k">def</span> <span class="n">transmit</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Sync</span><span class="o">](</span><span class="n">origin</span><span class="k">:</span> <span class="kt">InputStream</span><span class="o">,</span> <span class="n">destination</span><span class="k">:</span> <span class="kt">OutputStream</span><span class="o">,</span> <span class="n">buffer</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">],</span> <span class="n">acc</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
<span class="k">def</span> <span class="n">transfer</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Sync</span><span class="o">](</span><span class="n">origin</span><span class="k">:</span> <span class="kt">InputStream</span><span class="o">,</span> <span class="n">destination</span><span class="k">:</span> <span class="kt">OutputStream</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
<span class="k">def</span> <span class="n">inputStream</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Sync</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">File</span><span class="o">,</span> <span class="n">guard</span><span class="k">:</span> <span class="kt">Semaphore</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">Resource</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">FileInputStream</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
<span class="k">def</span> <span class="n">outputStream</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Sync</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">File</span><span class="o">,</span> <span class="n">guard</span><span class="k">:</span> <span class="kt">Semaphore</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">Resource</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">FileOutputStream</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
<span class="k">def</span> <span class="n">inputOutputStreams</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Sync</span><span class="o">](</span><span class="n">in</span><span class="k">:</span> <span class="kt">File</span><span class="o">,</span> <span class="n">out</span><span class="k">:</span> <span class="kt">File</span><span class="o">,</span> <span class="n">guard</span><span class="k">:</span> <span class="kt">Semaphore</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">Resource</span><span class="o">[</span><span class="kt">F</span>, <span class="o">(</span><span class="kt">InputStream</span>, <span class="kt">OutputStream</span><span class="o">)]</span> <span class="k">=</span> <span class="o">???</span>

<span class="k">def</span> <span class="n">copy</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Concurrent</span><span class="o">](</span><span class="n">origin</span><span class="k">:</span> <span class="kt">File</span><span class="o">,</span> <span class="n">destination</span><span class="k">:</span> <span class="kt">File</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="k">=</span> 
  <span class="k">for</span> <span class="o">{</span>
    <span class="n">guard</span> <span class="k">&lt;-</span> <span class="nc">Semaphore</span><span class="o">[</span><span class="kt">F</span><span class="o">](</span><span class="mi">1</span><span class="o">)</span>
    <span class="n">count</span> <span class="k">&lt;-</span> <span class="n">inputOutputStreams</span><span class="o">(</span><span class="n">origin</span><span class="o">,</span> <span class="n">destination</span><span class="o">,</span> <span class="n">guard</span><span class="o">).</span><span class="n">use</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">in</span><span class="o">,</span> <span class="n">out</span><span class="o">)</span> <span class="k">=&gt;</span> 
               <span class="n">guard</span><span class="o">.</span><span class="n">withPermit</span><span class="o">(</span><span class="n">transfer</span><span class="o">(</span><span class="n">in</span><span class="o">,</span> <span class="n">out</span><span class="o">))</span>
             <span class="o">}</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">count</span>
</code></pre></div></div>

<p>Only in our <code class="highlighter-rouge">main</code> function we will set <code class="highlighter-rouge">IO</code> as the final <code class="highlighter-rouge">F</code> for
our program. To do so, of course, a <code class="highlighter-rouge">Concurrent[IO]</code> instance must be in scope,
but that instance is brought transparently by <code class="highlighter-rouge">IOApp</code> so we do not need to be
concerned about it.</p>

<p>During the remaining of this tutorial we will use polymorphic code, only falling
to <code class="highlighter-rouge">IO</code> in the <code class="highlighter-rouge">run</code> method of our <code class="highlighter-rouge">IOApp</code>s. Polymorphic code is less
restrictive, as functions are not tied to <code class="highlighter-rouge">IO</code> but are applicable to any <code class="highlighter-rouge">F[_]</code>
as long as there is an instance of the type class required (<code class="highlighter-rouge">Sync[F[_]]</code> ,
<code class="highlighter-rouge">Concurrent[F[_]]</code>…) in scope. The type class to use will depend on the
requirements of our code. For example, if the execution of the side-effect
should be cancelable, then we must stick to <code class="highlighter-rouge">Concurrent[F[_]]</code>. Also, it is
actually easier to work on <code class="highlighter-rouge">F</code> than on any specific type.</p>

<h4 id="copy-program-code-polymorphic-version">Copy program code, polymorphic version</h4>
<p>The polymorphic version of our copy program in full is available
<a href="https://github.com/lrodero/cats-effect-tutorial/blob/replace_tcp_section_with_prodcons/src/main/scala/catsEffectTutorial/copyfile/CopyFilePolymorphic.scala">here</a>.</p>

<h3 id="exercises-improving-our-small-io-program">Exercises: improving our small <code class="highlighter-rouge">IO</code> program</h3>

<p>To finalize we propose you some exercises that will help you to keep improving
your IO-kungfu:</p>

<ol>
  <li>Modify the <code class="highlighter-rouge">IOApp</code> so it shows an error and abort the execution if the origin
and destination files are the same, the origin file cannot be open for
reading or the destination file cannot be opened for writing. Also, if the
destination file already exists, the program should ask for confirmation
before overwriting that file.</li>
  <li>Modify <code class="highlighter-rouge">transmit</code> so the buffer size is not hardcoded but passed as
parameter.</li>
  <li>Use some other concurrency tool of cats-effect instead of <code class="highlighter-rouge">semaphore</code> to
ensure mutual exclusion of <code class="highlighter-rouge">transfer</code> execution and streams closing.</li>
  <li>Create a new program able to copy folders. If the origin folder has
subfolders, then their contents must be recursively copied too. Of course the
copying must be safely cancelable at any moment.</li>
</ol>

<h2 id="producer-consumer-problem---concurrency-and-fibers">Producer-consumer problem - concurrency and fibers</h2>
<p>The <em>producer-consumer</em> pattern is often found in concurrent setups. Here one or
more producers insert data on a shared data structure like a queue or buffer
while one or more consumers extract data from it. Readers and writers run
concurrently. If the queue is empty then readers will block until data is
avaiable, if the queue is full then writers will wait for some ‘slot’ to be
free. Only one writer at a time can add data to the queue to prevent data
corruption. Also only one reader can extract data from the queue so no two
readers get the same data item.</p>

<p>Variations of this problem exists depending on whether there are more than one
consumer/producer, or whether the data structure siting between them is
size-bounded or not. Here we will first work on a solution for a single producer
and consumer setting for bounded and unbounded buffers, then we will evolve the
solution for multiple producers and consumers. In both cases we will use a
bounded queue as the shared data structure.</p>

<p>But before we work on the solution for this problem we must introduce <em>fibers</em>,
which are the basic building block of cats-effect concurrency.</p>

<h3 id="intro-to-fibers">Intro to fibers</h3>
<p>A fiber carries an <code class="highlighter-rouge">F</code> action to execute (typically an <code class="highlighter-rouge">IO</code> instance). Fibers
are like ‘light’ threads, meaning they can be used in a similar way than threads
to create concurrent code. However, they are <em>not</em> threads. Spawning new fibers
does not guarantee that the action described in the <code class="highlighter-rouge">F</code> associated to it will be
run if there is a shortage of threads. Internally cats-effect uses thread pools
to run fibers. So if there is no thread available in the pool then the fiber
execution will ‘wait’ until some thread is free again. <code class="highlighter-rouge">ContextShift[F]</code> is in
charge of assigning threads to the fibers waiting to be run. When using <code class="highlighter-rouge">IOApp</code>
we get also the <code class="highlighter-rouge">ContextShift[IO]</code> that we need to run the fibers in our code.
But the developer can create new <code class="highlighter-rouge">ContextShift[F]</code> instances using custom thread
pools.</p>

<p>Cats-effect implements some concurrency primitives to coordinate concurrent
fibers: <a href="https://typelevel.org/cats-effect/concurrency/deferred.html">Deferred</a>,
<a href="https://typelevel.org/cats-effect/concurrency/mvar.html">MVar2</a>,
<a href="https://typelevel.org/cats-effect/concurrency/ref.html">Ref</a> and
<a href="https://typelevel.org/cats-effect/concurrency/semaphore.html">Semaphore</a>. It is
important to understand that when a fiber gets blocked by some concurrent data
structure cats-effect just recycles the thread so it becomes available for other
fiber. Cats-effect also recovers threads of finished and cancelled fibers.  But
keep in mind that, in contrast, if the fiber is blocked by some external action
like waiting for some input from a TCP socket, then cats-effect has no way to
recover back that thread until the action finishes.</p>

<p>Way more detailed info about concurrency in cats-effect can be found in <a href="https://github.com/slouc/concurrency-in-scala-with-ce">this
other tutorial ‘Concurrency in Scala with
Cats-Effect’</a>. It is also
strongly advised to read the <a href="https://typelevel.org/cats-effect/concurrency/">Concurrency section of cats-effect
docs</a>. But for the remaining of
this tutorial we will focus on a practical approach to those concepts by
implementing a solution to the producer-consumer problem. Ok, now we have
briefly discussed fibers we can start working on our producer-consumer problem.</p>

<h3 id="single-producer-consumer-with-unbounded-buffer-naive-implementation">Single producer-consumer with unbounded buffer, naive implementation</h3>
<p>This is the simplest scenario. We have an intermediate structure where one
producer inserts data to and one consumer extracts data from. First of all we
define the functions that will create the data for the producer (<code class="highlighter-rouge">create</code>) and
will process that data for the consumer (<code class="highlighter-rouge">process</code>). For the sake of simplicity
<code class="highlighter-rouge">create</code> will just generate a sequence of integers (<code class="highlighter-rouge">1</code>, <code class="highlighter-rouge">2</code>, <code class="highlighter-rouge">3</code>, …) and
<code class="highlighter-rouge">process</code> will only check that the received integer is the one expected. This
check will be handy to detect whether our implementation has problems such as
race conditions.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.IO</span>
<span class="k">import</span> <span class="nn">java.util.concurrent.atomic.AtomicInteger</span>

<span class="k">val</span> <span class="n">prev</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">AtomicInteger</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="c1">// No need to make it atomic for a single consumer, but convinient
</span><span class="k">def</span> <span class="n">process</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="kt">:</span> <span class="kt">Sync</span><span class="o">](</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">Sync</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">delay</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">prev</span><span class="o">.</span><span class="n">compareAndSet</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">i</span><span class="o">))</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nc">Exception</span><span class="o">(</span><span class="n">s</span><span class="s">"Race condition, it should be ${prev.incrementAndGet()} but is $i"</span><span class="o">)</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">10000</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
      <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Processed $i elements"</span><span class="o">)</span>
  <span class="o">}</span>

<span class="k">val</span> <span class="n">counter</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">AtomicInteger</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="c1">// No need to make it atomit for a single producer, but convinient
</span><span class="k">def</span> <span class="n">create</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="kt">:</span> <span class="kt">Sync</span><span class="o">]</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">Sync</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">delay</span><span class="o">(</span><span class="n">counter</span><span class="o">.</span><span class="n">incrementAndGet</span><span class="o">())</span>
</code></pre></div></div>

<p>Now we can implement our producer and consumer. Let’s start with a ‘naive’
implementation:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.IO</span>
<span class="k">import</span> <span class="nn">cats.implicits._</span>
<span class="k">import</span> <span class="nn">scala.collection.mutable</span>

<span class="k">def</span> <span class="n">process</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="kt">:</span> <span class="kt">Sync</span><span class="o">](</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span> <span class="c1">// As defined before
</span><span class="k">def</span> <span class="n">create</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="kt">:</span> <span class="kt">Sync</span><span class="o">]</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span> <span class="c1">// As defined before
</span>
<span class="k">def</span> <span class="n">producer</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="kt">:</span> <span class="kt">Sync</span><span class="o">](</span><span class="n">buffer</span><span class="k">:</span> <span class="kt">mutable.Buffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="n">i</span> <span class="k">&lt;-</span> <span class="n">create</span>
    <span class="k">_</span> <span class="k">&lt;-</span> <span class="nc">Sync</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">delay</span><span class="o">(</span><span class="n">buffer</span><span class="o">.</span><span class="n">append</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>
    <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">producer</span><span class="o">(</span><span class="n">buffer</span><span class="o">)</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="o">()</span>

<span class="k">def</span> <span class="n">consumer</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="kt">:</span> <span class="kt">Sync</span><span class="o">](</span><span class="n">buffer</span><span class="k">:</span> <span class="kt">mutable.Buffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="n">iO</span> <span class="k">&lt;-</span> <span class="nc">Sync</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">delay</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">buffer</span><span class="o">.</span><span class="n">nonEmpty</span><span class="o">)</span> <span class="nc">Option</span><span class="o">(</span><span class="n">buffer</span><span class="o">.</span><span class="n">remove</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span>
      <span class="k">else</span> <span class="nc">None</span>
    <span class="o">}</span>
    <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">iO</span><span class="o">.</span><span class="n">fold</span><span class="o">(</span><span class="nc">Sync</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">unit</span><span class="o">)(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="n">process</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>
    <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">consumer</span><span class="o">(</span><span class="n">buffer</span><span class="o">)</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="o">()</span>
</code></pre></div></div>

<p>The <code class="highlighter-rouge">producer</code> function invokes <code class="highlighter-rouge">create</code> to get a new data item, then adds it to
the buffer. The <code class="highlighter-rouge">consumer</code> function on the other hand checkes whether if there
is any data in the buffer and if so it calls it feeds it to <code class="highlighter-rouge">process</code>. When done
each function calls itself recursively to start the process anew. As cats-effect
<code class="highlighter-rouge">IO</code> is stack-safe we are not concerned with stack overflown exceptions.</p>

<p>We can now create a program that instantiates the buffer and runs both
<code class="highlighter-rouge">producer</code> and <code class="highlighter-rouge">consumer</code> in parallel:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.</span><span class="o">{</span><span class="nc">ExitCode</span><span class="o">,</span> <span class="nc">IO</span><span class="o">,</span> <span class="nc">IOApp</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">cats.implicits._</span>
<span class="k">import</span> <span class="nn">scala.collection.mutable</span>

<span class="k">object</span> <span class="nc">NaiveProducerConsumer</span> <span class="k">extends</span> <span class="nc">IOApp</span> <span class="o">{</span>

  <span class="k">def</span> <span class="n">process</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="kt">:</span> <span class="kt">Sync</span><span class="o">](</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span> <span class="c1">// As defined before
</span>  <span class="k">def</span> <span class="n">create</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="kt">:</span> <span class="kt">Sync</span><span class="o">]</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span> <span class="c1">// As defined before
</span>  
  <span class="k">def</span> <span class="n">consumer</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="kt">:</span> <span class="kt">Sync</span><span class="o">](</span><span class="n">buffer</span><span class="k">:</span> <span class="kt">mutable.Buffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span> <span class="c1">// As defined before
</span>  <span class="k">def</span> <span class="n">producer</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="kt">:</span> <span class="kt">Sync</span><span class="o">](</span><span class="n">buffer</span><span class="k">:</span> <span class="kt">mutable.Buffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span> <span class="c1">// As defined before
</span>  
  <span class="k">override</span> <span class="k">def</span> <span class="n">run</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">ExitCode</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">for</span> <span class="o">{</span>
      <span class="n">buffer</span> <span class="k">&lt;-</span> <span class="nc">IO</span><span class="o">(</span><span class="k">new</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">ListBuffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">]())</span>
      <span class="n">res</span>    <span class="k">&lt;-</span> <span class="o">(</span><span class="n">producer</span><span class="o">[</span><span class="kt">IO</span><span class="o">](</span><span class="n">buffer</span><span class="o">),</span> <span class="n">consumer</span><span class="o">[</span><span class="kt">IO</span><span class="o">](</span><span class="n">buffer</span><span class="o">))</span>
        <span class="o">.</span><span class="n">parMapN</span><span class="o">((</span><span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">ExitCode</span><span class="o">.</span><span class="nc">Success</span><span class="o">)</span> <span class="c1">// Run producer and consumer in parallel until done (likely by user cancelling with CTRL-C)
</span>        <span class="o">.</span><span class="n">handleErrorWith</span> <span class="o">{</span> <span class="n">t</span> <span class="k">=&gt;</span>
          <span class="nc">IO</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Error caught: ${t.getMessage}"</span><span class="o">)).</span><span class="n">as</span><span class="o">(</span><span class="nc">ExitCode</span><span class="o">.</span><span class="nc">Error</span><span class="o">)</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">yield</span> <span class="n">res</span>

<span class="o">}</span>
</code></pre></div></div>

<p>The full implementation of this naive producer consumer is available
<a href="https://github.com/lrodero/cats-effect-tutorial/blob/replace_tcp_section_with_prodcons/src/main/scala/catsEffectTutorial/producerconsumer/NaiveProducerConsumer.scala">here</a>.</p>

<p>Our <code class="highlighter-rouge">run</code> function instantiates the shared <code class="highlighter-rouge">buffer</code> and boots the producer and
consumer in parallel. To do to it uses <code class="highlighter-rouge">parMapN</code>, that creates and runs the
fibers that will run the <code class="highlighter-rouge">IO</code>s passed as paremeter. Program will run until an
error is thrown by either the consumer or producer, or execution is cancelled
<em>e.g.</em> by the user pressing CTRL-C.</p>

<p>Alternatively we could have used <code class="highlighter-rouge">start</code> to explicitely create new <code class="highlighter-rouge">Fiber</code>
instances that will run the producer and consumer, then use <code class="highlighter-rouge">join</code> to wait for
them to finish, something like:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.</span><span class="o">{</span><span class="nc">ExitCode</span><span class="o">,</span> <span class="nc">IO</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">cats.implicits._</span>
<span class="k">import</span> <span class="nn">scala.collection.mutable</span>

<span class="k">object</span> <span class="nc">NaiveProducerConsumer</span> <span class="k">extends</span> <span class="nc">IOApp</span> <span class="o">{</span>

  <span class="k">def</span> <span class="n">process</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="kt">:</span> <span class="kt">Sync</span><span class="o">](</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span> <span class="c1">// As defined before
</span>  <span class="k">def</span> <span class="n">create</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="kt">:</span> <span class="kt">Sync</span><span class="o">]</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span> <span class="c1">// As defined before
</span>  
  <span class="k">def</span> <span class="n">consumer</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="kt">:</span> <span class="kt">Sync</span><span class="o">](</span><span class="n">buffer</span><span class="k">:</span> <span class="kt">mutable.Buffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span> <span class="c1">// As defined before
</span>  <span class="k">def</span> <span class="n">producer</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="kt">:</span> <span class="kt">Sync</span><span class="o">](</span><span class="n">buffer</span><span class="k">:</span> <span class="kt">mutable.Buffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span> <span class="c1">// As defined before
</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">run</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">ExitCode</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">for</span> <span class="o">{</span>
      <span class="n">buffer</span> <span class="k">&lt;-</span> <span class="nc">IO</span><span class="o">(</span><span class="k">new</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">ListBuffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">]())</span>
      <span class="n">producerFiber</span> <span class="k">&lt;-</span> <span class="n">producer</span><span class="o">[</span><span class="kt">IO</span><span class="o">](</span><span class="n">buffer</span><span class="o">).</span><span class="n">start</span>
      <span class="n">consumerFiber</span> <span class="k">&lt;-</span> <span class="n">consumer</span><span class="o">[</span><span class="kt">IO</span><span class="o">](</span><span class="n">buffer</span><span class="o">).</span><span class="n">start</span>
      <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">producerFiber</span><span class="o">.</span><span class="n">join</span>
      <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">consumerFiber</span><span class="o">.</span><span class="n">join</span>
    <span class="o">}</span> <span class="k">yield</span> <span class="nc">ExitCode</span><span class="o">.</span><span class="nc">Error</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Problem is, if there is an error in any of the fibers the <code class="highlighter-rouge">join</code> call will not
hint it, nor it will return. In contrast <code class="highlighter-rouge">parMapN</code> does promote the error it
finds to the caller.</p>

<p>Ok, we stick to our implementation based on <code class="highlighter-rouge">.parMapN</code>. Are we done? Does it
Work? Well, unfortunately, <em>if we run the program we will find errors</em>. These
are due to race conditions as our naive implementation does not make a good job
ensuring that the shared buffer is accessed in an orderly manner. In the next
section we will ensure proper access control using cats-effect’s semaphores.</p>

<h3 id="single-producer-consumer-with-unbounded-buffer-using-semaphores">Single producer-consumer with unbounded buffer using semaphores</h3>
<p>Semaphores are used to control access to critical sections of our code that handle
shared resources, when those sections can be run concurrently. Each semaphore
contains a number that represents <em>permits</em>. To access a critical section
permits have to be obtained, later to be freed when the critical section is
left.</p>

<p>In our example the shared resource is the buffer, and the critical sections are
the parts that access to it <code class="highlighter-rouge">producer</code> and <code class="highlighter-rouge">consumer</code>. We protect those sections
using a semaphore <code class="highlighter-rouge">lock</code> with one permit. The semaphore will be created in the
main <code class="highlighter-rouge">run</code> function and then passed down the line:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.</span><span class="o">{</span><span class="nc">ExitCode</span><span class="o">,</span> <span class="nc">IO</span><span class="o">,</span> <span class="nc">IOApp</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">cats.effect.concurrent.Semaphore</span>
<span class="k">import</span> <span class="nn">cats.implicits._</span>

<span class="k">import</span> <span class="nn">scala.collection.mutable</span>

<span class="k">object</span> <span class="nc">SemaphoreProducerConsumerUnboundedQueue</span> <span class="k">extends</span> <span class="nc">IOApp</span> <span class="o">{</span>

  <span class="k">def</span> <span class="n">process</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="kt">:</span> <span class="kt">Sync</span><span class="o">](</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span> <span class="c1">// As defined before
</span>  <span class="k">def</span> <span class="n">create</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="kt">:</span> <span class="kt">Sync</span><span class="o">]</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span> <span class="c1">// As defined before
</span>
  <span class="k">def</span> <span class="n">producer</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="kt">:</span> <span class="kt">Sync</span><span class="o">](</span><span class="n">buffer</span><span class="k">:</span> <span class="kt">mutable.Buffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">],</span> <span class="n">lock</span><span class="k">:</span> <span class="kt">Semaphore</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">for</span> <span class="o">{</span>
      <span class="n">i</span> <span class="k">&lt;-</span> <span class="n">create</span>
      <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">lock</span><span class="o">.</span><span class="n">acquire</span> <span class="c1">// Enter critical section, wait if lock already acquired
</span>      <span class="k">_</span> <span class="k">&lt;-</span> <span class="nc">Sync</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">delay</span><span class="o">(</span><span class="n">buffer</span><span class="o">.</span><span class="n">append</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>
      <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">lock</span><span class="o">.</span><span class="n">release</span> <span class="c1">// Leave critical section
</span>      <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">producer</span><span class="o">(</span><span class="n">buffer</span><span class="o">,</span> <span class="n">lock</span><span class="o">)</span>
    <span class="o">}</span> <span class="k">yield</span> <span class="o">()</span>

  <span class="k">def</span> <span class="n">consumer</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="kt">:</span> <span class="kt">Sync</span><span class="o">](</span><span class="n">buffer</span><span class="k">:</span> <span class="kt">mutable.Buffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">],</span> <span class="n">lock</span><span class="k">:</span> <span class="kt">Semaphore</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">for</span> <span class="o">{</span>
      <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">lock</span><span class="o">.</span><span class="n">acquire</span> <span class="c1">// Enter critical section, wait if lock already acquired
</span>      <span class="n">iO</span> <span class="k">&lt;-</span> <span class="nc">Sync</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">delay</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">buffer</span><span class="o">.</span><span class="n">nonEmpty</span><span class="o">)</span> <span class="nc">Option</span><span class="o">(</span><span class="n">buffer</span><span class="o">.</span><span class="n">remove</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span>
        <span class="k">else</span> <span class="nc">None</span>
      <span class="o">}</span>
      <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">lock</span><span class="o">.</span><span class="n">release</span> <span class="c1">// Leave critical section
</span>      <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">iO</span><span class="o">.</span><span class="n">fold</span><span class="o">(</span><span class="nc">Sync</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">unit</span><span class="o">)(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="n">process</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>
      <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">consumer</span><span class="o">(</span><span class="n">buffer</span><span class="o">,</span> <span class="n">lock</span><span class="o">)</span>
    <span class="o">}</span> <span class="k">yield</span> <span class="o">()</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">run</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">ExitCode</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">for</span> <span class="o">{</span>
      <span class="n">buffer</span> <span class="k">&lt;-</span> <span class="nc">IO</span><span class="o">(</span><span class="k">new</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">ListBuffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">]())</span>
      <span class="n">lock</span> <span class="k">&lt;-</span> <span class="nc">Semaphore</span><span class="o">[</span><span class="kt">IO</span><span class="o">](</span><span class="mi">1</span><span class="o">)</span>
      <span class="n">res</span> <span class="k">&lt;-</span> <span class="o">(</span><span class="n">producer</span><span class="o">(</span><span class="n">buffer</span><span class="o">,</span> <span class="n">lock</span><span class="o">),</span> <span class="n">consumer</span><span class="o">(</span><span class="n">buffer</span><span class="o">,</span> <span class="n">lock</span><span class="o">))</span>
        <span class="o">.</span><span class="n">parMapN</span><span class="o">((</span><span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">ExitCode</span><span class="o">.</span><span class="nc">Success</span><span class="o">)</span> <span class="c1">// Run producer and consumer in parallel until done (likely by user cancelling with CTRL-C)
</span>        <span class="o">.</span><span class="n">handleErrorWith</span> <span class="o">{</span> <span class="n">t</span> <span class="k">=&gt;</span>
          <span class="nc">IO</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Error caught: ${t.getMessage}"</span><span class="o">)).</span><span class="n">as</span><span class="o">(</span><span class="nc">ExitCode</span><span class="o">.</span><span class="nc">Error</span><span class="o">)</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">yield</span> <span class="n">res</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The full implementation of this producer consumer is available
<a href="https://github.com/lrodero/cats-effect-tutorial/blob/replace_tcp_section_with_prodcons/src/main/scala/catsEffectTutorial/producerconsumer/SemaphoreProducerConsumerUnboundedQueue.scala">here</a>.</p>

<p>So, this code is race conditions safe. There is no way that both producer and
consumer access at the same time their critical sections. If the <code class="highlighter-rouge">consumer</code>
function has acquired the permit in the semaphore (<code class="highlighter-rouge">lock</code>) then <code class="highlighter-rouge">producer</code> will
have to wait until <code class="highlighter-rouge">consumer</code> finishes and <code class="highlighter-rouge">release</code>s it. The same applies if
<code class="highlighter-rouge">producer</code> acquires <code class="highlighter-rouge">lock</code> first. In fact this pattern of getting and then
releasing a single permit to control access to a critical section is so often
used that there is a specific call for that, <code class="highlighter-rouge">.withPermit</code>. Using that call to
rewrite <code class="highlighter-rouge">producer</code> we would have:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.concurrent.Semaphore</span>
<span class="k">import</span> <span class="nn">cats.effect.IO</span>
<span class="k">import</span> <span class="nn">cats.implicits._</span>

<span class="k">import</span> <span class="nn">scala.collection.mutable</span>

<span class="k">def</span> <span class="n">producer</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="kt">:</span> <span class="kt">Sync</span><span class="o">](</span><span class="n">buffer</span><span class="k">:</span> <span class="kt">mutable.Buffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">],</span> <span class="n">lock</span><span class="k">:</span> <span class="kt">Semaphore</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="n">i</span> <span class="k">&lt;-</span> <span class="n">create</span>
    <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">lock</span><span class="o">.</span><span class="n">withPermit</span> <span class="o">{</span> <span class="c1">// Enter critical section, wait if lock already acquired, release when done
</span>      <span class="nc">Sync</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">delay</span><span class="o">(</span><span class="n">buffer</span><span class="o">.</span><span class="n">append</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>
    <span class="o">}</span>
    <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">producer</span><span class="o">(</span><span class="n">buffer</span><span class="o">,</span> <span class="n">lock</span><span class="o">)</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="o">()</span>
</code></pre></div></div>

<p>As a brief exercise you can try to reimplement <code class="highlighter-rouge">consumer</code> using the
<code class="highlighter-rouge">.withPermit</code> call.</p>

<p>Now this code is safe but not terribly efficient. Note that <code class="highlighter-rouge">consumer</code> runs even
when there is no data to be read, in such case it will not invoke <code class="highlighter-rouge">process</code>. If
the producer is ‘slow’ to create new data then <code class="highlighter-rouge">consumer</code> will often run with no
purpose (as the buffer will be empty) and so pointlessly using CPU. Ideally the
semaphore will block the consumer until some data is available.</p>

<p>To solve this we can use an additional semaphore that counts the number of items
in the buffer, we will call this semaphore <code class="highlighter-rouge">filled</code>. The <code class="highlighter-rouge">producer</code> function
will add a new permit to the semaphore every time it inserts a new data item in
the buffer, while <code class="highlighter-rouge">consumer</code> will ask for a permit from that semaphore before
proceeding to extract a data item. Now we are sure that whenever <code class="highlighter-rouge">consumer</code>
access the buffer there will be data to read, so we do not need to check if the
buffer is empty prior to access it.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.ExitCase.</span><span class="o">{</span><span class="nc">Canceled</span><span class="o">,</span> <span class="nc">Completed</span><span class="o">,</span> <span class="nc">Error</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">cats.effect.concurrent.Semaphore</span>
<span class="k">import</span> <span class="nn">cats.effect.</span><span class="o">{</span><span class="nc">ExitCode</span><span class="o">,</span> <span class="nc">IO</span><span class="o">,</span> <span class="nc">IOApp</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">cats.implicits._</span>

<span class="k">import</span> <span class="nn">scala.collection.mutable</span>

<span class="k">object</span> <span class="nc">SemaphoreProducerConsumerUnboundedQueuev2</span> <span class="k">extends</span> <span class="nc">IOApp</span> <span class="o">{</span>

  <span class="k">def</span> <span class="n">process</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="kt">:</span> <span class="kt">Sync</span><span class="o">](</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span> <span class="c1">// As defined before
</span>  <span class="k">def</span> <span class="n">create</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="kt">:</span> <span class="kt">Sync</span><span class="o">]</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span> <span class="c1">// As defined before
</span>
  <span class="k">def</span> <span class="n">producer</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="kt">:</span> <span class="kt">Sync</span><span class="o">](</span><span class="n">buffer</span><span class="k">:</span> <span class="kt">mutable.Buffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">],</span> <span class="n">lock</span><span class="k">:</span> <span class="kt">Semaphore</span><span class="o">[</span><span class="kt">F</span><span class="o">],</span> <span class="n">filled</span><span class="k">:</span> <span class="kt">Semaphore</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">for</span> <span class="o">{</span>
      <span class="n">i</span> <span class="k">&lt;-</span> <span class="n">create</span>
      <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">lock</span><span class="o">.</span><span class="n">withPermit</span> <span class="o">{</span> <span class="c1">// Enter critical section, wait if lock already acquired, release when done
</span>        <span class="nc">Sync</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">delay</span><span class="o">(</span><span class="n">buffer</span><span class="o">.</span><span class="n">append</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>
      <span class="o">}</span>
      <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">filled</span><span class="o">.</span><span class="n">release</span>    <span class="c1">// Signal new item in buffer
</span>      <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">producer</span><span class="o">(</span><span class="n">buffer</span><span class="o">,</span> <span class="n">lock</span><span class="o">,</span> <span class="n">filled</span><span class="o">)</span>
    <span class="o">}</span> <span class="k">yield</span> <span class="o">()</span>

  <span class="k">def</span> <span class="n">consumer</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="kt">:</span> <span class="kt">Sync</span><span class="o">](</span><span class="n">buffer</span><span class="k">:</span> <span class="kt">mutable.Buffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">],</span> <span class="n">lock</span><span class="k">:</span> <span class="kt">Semaphore</span><span class="o">[</span><span class="kt">F</span><span class="o">],</span> <span class="n">filled</span><span class="k">:</span> <span class="kt">Semaphore</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">for</span> <span class="o">{</span>
      <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">filled</span><span class="o">.</span><span class="n">acquire</span>    <span class="c1">// Wait for some item in buffer
</span>      <span class="n">i</span> <span class="k">&lt;-</span> <span class="n">lock</span><span class="o">.</span><span class="n">withPermit</span> <span class="o">{</span> <span class="c1">// Enter critical section, wait if lock already acquired, release when done
</span>        <span class="nc">Sync</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">delay</span><span class="o">(</span><span class="n">buffer</span><span class="o">.</span><span class="n">remove</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span>
      <span class="o">}</span>
      <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">process</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>
      <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">consumer</span><span class="o">(</span><span class="n">buffer</span><span class="o">,</span> <span class="n">lock</span><span class="o">,</span> <span class="n">filled</span><span class="o">)</span>
    <span class="o">}</span> <span class="k">yield</span> <span class="o">()</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">run</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">ExitCode</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">for</span> <span class="o">{</span>
      <span class="n">buffer</span> <span class="k">&lt;-</span> <span class="nc">IO</span><span class="o">(</span><span class="k">new</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">ListBuffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">]())</span>
      <span class="n">lock</span>   <span class="k">&lt;-</span> <span class="nc">Semaphore</span><span class="o">[</span><span class="kt">IO</span><span class="o">](</span><span class="mi">1</span><span class="o">)</span>
      <span class="n">filled</span> <span class="k">&lt;-</span> <span class="nc">Semaphore</span><span class="o">[</span><span class="kt">IO</span><span class="o">](</span><span class="mi">0</span><span class="o">)</span>
      <span class="n">res</span>    <span class="k">&lt;-</span> <span class="o">(</span><span class="n">producer</span><span class="o">(</span><span class="n">buffer</span><span class="o">,</span> <span class="n">lock</span><span class="o">,</span> <span class="n">filled</span><span class="o">),</span> <span class="n">consumer</span><span class="o">(</span><span class="n">buffer</span><span class="o">,</span> <span class="n">lock</span><span class="o">,</span> <span class="n">filled</span><span class="o">))</span>
        <span class="o">.</span><span class="n">parMapN</span><span class="o">((</span><span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">ExitCode</span><span class="o">.</span><span class="nc">Success</span><span class="o">)</span> <span class="c1">// Run producer and consumer in parallel until done (likely by user cancelling with CTRL-C)
</span>        <span class="o">.</span><span class="n">handleErrorWith</span> <span class="o">{</span> <span class="n">t</span> <span class="k">=&gt;</span>
          <span class="nc">IO</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Error caught: ${t.getMessage}"</span><span class="o">)).</span><span class="n">as</span><span class="o">(</span><span class="nc">ExitCode</span><span class="o">.</span><span class="nc">Error</span><span class="o">)</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">yield</span> <span class="n">res</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The full implementation of this producer consumer is available
<a href="https://github.com/lrodero/cats-effect-tutorial/blob/replace_tcp_section_with_prodcons/src/main/scala/catsEffectTutorial/producerconsumer/SemaphoreProducerConsumerUnboundedQueuev2.scala">here</a>.</p>

<p>The <code class="highlighter-rouge">consumer</code> function will wait for having some data available by the call to
<code class="highlighter-rouge">filled.acquire</code>, which will block until the <code class="highlighter-rouge">filled</code> semaphore has some permit.
On the other hand the <code class="highlighter-rouge">producer</code> function signals that there is new data in the
buffer by calling <code class="highlighter-rouge">fill.release</code> which increases the amount of permits.</p>

<p>Note that if <code class="highlighter-rouge">producer</code> had inserted, let’s say, 5 data items, we will increase
the number of permits by 5 as well with <code class="highlighter-rouge">fill.releaseN(5)</code>. The same applies for
the <code class="highlighter-rouge">consumer</code> function; if it required, let’s say, 10 data items, then it will
had to acquire that number of permits with <code class="highlighter-rouge">fill.acquireN(10)</code> before
proceeding. As you have probable guessed, <code class="highlighter-rouge">.acquire</code> and <code class="highlighter-rouge">.release</code> are
equivalent to <code class="highlighter-rouge">.acquireN(1)</code> and <code class="highlighter-rouge">.releaseN(1)</code>.</p>

<h3 id="multiple-producer-consumer-with-unbounded-buffer-using-semaphores">Multiple producer-consumer with unbounded buffer using semaphores</h3>
<p>You may have not noticed, but the code in the previous section is already able
to handle multiple producers and consumers simultaneously. The only change to do
is to remove the check in the <code class="highlighter-rouge">process</code> funcion that we introduced at the
beginning. Why is that? Well, that funtion checked that values received by the
<code class="highlighter-rouge">process</code>  function follow the sequence generated (<code class="highlighter-rouge">1</code>, <code class="highlighter-rouge">2</code>, <code class="highlighter-rouge">3</code>…). But as now
there can be several consumers it could be very well that, for example, some
consumer gets value <code class="highlighter-rouge">5</code>, but before passing it to <code class="highlighter-rouge">process</code> another consumer
gets <code class="highlighter-rouge">6</code> and invokes <code class="highlighter-rouge">process</code> on that value. That will raise an error as we
are not passing values to <code class="highlighter-rouge">process</code> in sequential order.</p>

<p>As we have now several concurrent producers then there will be concurrent calls
to the <code class="highlighter-rouge">create</code> function, all of them modifying the same <code class="highlighter-rouge">counter</code> instance at
the same time. Fortunately <code class="highlighter-rouge">counter</code> is an instance of <code class="highlighter-rouge">AtomicInteger</code> so it is
protected against concurrent accesses. If that was not the case we would need to
protect <code class="highlighter-rouge">counter</code>.</p>

<p>To check that our implementation (after modifying <code class="highlighter-rouge">process</code> as mentioned before)
can handle several producers and consumers the main program will be modified so
it starts <code class="highlighter-rouge">10</code> producers and <code class="highlighter-rouge">10</code> consumers. Also each producer/consumer will
contain an <code class="highlighter-rouge">id</code> and will log a message to the console for each 1000 items
produced/consumed so we can see that all producers/consumers are alive and
kicking.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">java.util.concurrent.atomic.AtomicInteger</span>

<span class="k">import</span> <span class="nn">cats.effect.concurrent.Semaphore</span>
<span class="k">import</span> <span class="nn">cats.effect.</span><span class="o">{</span><span class="nc">ExitCode</span><span class="o">,</span> <span class="nc">IO</span><span class="o">,</span> <span class="nc">IOApp</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">cats.implicits._</span>

<span class="k">import</span> <span class="nn">scala.collection.mutable</span>

<span class="k">object</span> <span class="nc">SemaphoreMultiplesProducerConsumerUnboundedQueue</span> <span class="k">extends</span> <span class="nc">IOApp</span> <span class="o">{</span>

  <span class="k">def</span> <span class="n">process</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="kt">:</span> <span class="kt">Sync</span><span class="o">](</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Sync</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">delay</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">10000</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
        <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Processed $i elements"</span><span class="o">)</span>
    <span class="o">}</span>

  <span class="k">val</span> <span class="n">counter</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">AtomicInteger</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">create</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="kt">:</span> <span class="kt">Sync</span><span class="o">]</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Sync</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">delay</span><span class="o">(</span><span class="n">counter</span><span class="o">.</span><span class="n">incrementAndGet</span><span class="o">())</span>

  <span class="k">def</span> <span class="n">producer</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="kt">:</span> <span class="kt">Sync</span><span class="o">](</span><span class="n">id</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">count</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">buffer</span><span class="k">:</span> <span class="kt">mutable.Buffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">],</span> <span class="n">lock</span><span class="k">:</span> <span class="kt">Semaphore</span><span class="o">[</span><span class="kt">F</span><span class="o">],</span> <span class="n">filled</span><span class="k">:</span> <span class="kt">Semaphore</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">for</span> <span class="o">{</span>
      <span class="n">i</span> <span class="k">&lt;-</span> <span class="n">create</span>
      <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">lock</span><span class="o">.</span><span class="n">withPermit</span> <span class="o">{</span> <span class="c1">// Enter critical section, wait if lock already acquired, release when done
</span>        <span class="nc">Sync</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">delay</span><span class="o">(</span><span class="n">buffer</span><span class="o">.</span><span class="n">append</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>
      <span class="o">}</span>
      <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">filled</span><span class="o">.</span><span class="n">release</span>    <span class="c1">// Signal new item in buffer
</span>      <span class="n">newCount</span> <span class="k">=</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span>
      <span class="k">_</span> <span class="k">&lt;-</span> <span class="k">if</span> <span class="o">(</span><span class="n">newCount</span> <span class="o">%</span> <span class="mi">1000</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="nc">Sync</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">delay</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Producer $id has produced $newCount items"</span><span class="o">))</span> <span class="k">else</span> <span class="nc">Sync</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">unit</span>
      <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">producer</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">newCount</span><span class="o">,</span> <span class="n">buffer</span><span class="o">,</span> <span class="n">lock</span><span class="o">,</span> <span class="n">filled</span><span class="o">)</span>
    <span class="o">}</span> <span class="k">yield</span> <span class="o">()</span>

  <span class="k">def</span> <span class="n">consumer</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="kt">:</span> <span class="kt">Sync</span><span class="o">](</span><span class="n">id</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">count</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">buffer</span><span class="k">:</span> <span class="kt">mutable.Buffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">],</span> <span class="n">lock</span><span class="k">:</span> <span class="kt">Semaphore</span><span class="o">[</span><span class="kt">F</span><span class="o">],</span> <span class="n">filled</span><span class="k">:</span> <span class="kt">Semaphore</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">for</span> <span class="o">{</span>
      <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">filled</span><span class="o">.</span><span class="n">acquire</span>    <span class="c1">// Wait for some item in buffer
</span>      <span class="n">i</span> <span class="k">&lt;-</span> <span class="n">lock</span><span class="o">.</span><span class="n">withPermit</span> <span class="o">{</span> <span class="c1">// Enter critical section, wait if lock already acquired, release when done
</span>        <span class="nc">Sync</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">delay</span><span class="o">(</span><span class="n">buffer</span><span class="o">.</span><span class="n">remove</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span>
      <span class="o">}</span>
      <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">process</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>
      <span class="n">newCount</span> <span class="k">=</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span>
      <span class="k">_</span> <span class="k">&lt;-</span> <span class="k">if</span> <span class="o">(</span><span class="n">newCount</span> <span class="o">%</span> <span class="mi">1000</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="nc">Sync</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">delay</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Consumer $id has consumed $newCount items"</span><span class="o">))</span> <span class="k">else</span> <span class="nc">Sync</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">unit</span>
      <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">consumer</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">newCount</span><span class="o">,</span> <span class="n">buffer</span><span class="o">,</span> <span class="n">lock</span><span class="o">,</span> <span class="n">filled</span><span class="o">)</span>
    <span class="o">}</span> <span class="k">yield</span> <span class="o">()</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">run</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">ExitCode</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">for</span> <span class="o">{</span>
      <span class="n">buffer</span> <span class="k">&lt;-</span> <span class="nc">IO</span><span class="o">(</span><span class="k">new</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">ListBuffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">]())</span>
      <span class="n">lock</span> <span class="k">&lt;-</span> <span class="nc">Semaphore</span><span class="o">[</span><span class="kt">IO</span><span class="o">](</span><span class="mi">1</span><span class="o">)</span>
      <span class="n">filled</span> <span class="k">&lt;-</span> <span class="nc">Semaphore</span><span class="o">[</span><span class="kt">IO</span><span class="o">](</span><span class="mi">0</span><span class="o">)</span>
      <span class="n">producers</span> <span class="k">&lt;-</span> <span class="nc">List</span><span class="o">.</span><span class="n">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">11</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">producer</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">buffer</span><span class="o">,</span> <span class="n">lock</span><span class="o">,</span> <span class="n">filled</span><span class="o">)).</span><span class="n">pure</span><span class="o">[</span><span class="kt">IO</span><span class="o">]</span> <span class="c1">// 10 producers
</span>      <span class="n">consumers</span> <span class="k">&lt;-</span> <span class="nc">List</span><span class="o">.</span><span class="n">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">11</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">consumer</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">buffer</span><span class="o">,</span> <span class="n">lock</span><span class="o">,</span> <span class="n">filled</span><span class="o">)).</span><span class="n">pure</span><span class="o">[</span><span class="kt">IO</span><span class="o">]</span> <span class="c1">// 10 consumers
</span>      <span class="n">res</span> <span class="k">&lt;-</span> <span class="o">(</span><span class="n">producers</span> <span class="o">++</span> <span class="n">consumers</span><span class="o">)</span>
        <span class="o">.</span><span class="n">parSequence</span> <span class="c1">// Run producers and consumers in parallel until done (likely by user cancelling with CTRL-C)
</span>        <span class="o">.</span><span class="n">as</span><span class="o">(</span><span class="nc">ExitCode</span><span class="o">.</span><span class="nc">Success</span><span class="o">)</span>
        <span class="o">.</span><span class="n">handleErrorWith</span> <span class="o">{</span> <span class="n">t</span> <span class="k">=&gt;</span>
          <span class="nc">IO</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Error caught: ${t.getMessage}"</span><span class="o">)).</span><span class="n">as</span><span class="o">(</span><span class="nc">ExitCode</span><span class="o">.</span><span class="nc">Error</span><span class="o">)</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">yield</span> <span class="n">res</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The full implementation of this producer consumer with unbounded queue is available
<a href="https://github.com/lrodero/cats-effect-tutorial/blob/replace_tcp_section_with_prodcons/src/main/scala/catsEffectTutorial/producerconsumer/SemaphoreMultiplesProducerConsumerUnboundedQueue.scala">here</a>.</p>

<p>Now producers and consumers are started all in parallel by means of
<code class="highlighter-rouge">.parSequence</code>. This call will transform the <code class="highlighter-rouge">List[IO[Unit]]</code> passed as
parameter and transform it into <code class="highlighter-rouge">IO[List[Unit]]</code>. We could have used <code class="highlighter-rouge">parMapM</code>
here as well but in this case <code class="highlighter-rouge">.parSequence</code> is way more handy. All <code class="highlighter-rouge">IO</code>
instances are started concurrently in their own fiber. As with <code class="highlighter-rouge">.parMapN</code>, the
<code class="highlighter-rouge">parSequence</code> call will not return until all <code class="highlighter-rouge">IO</code>s are finished or any of them
is halted by an error or cancelled. If all <code class="highlighter-rouge">IO</code>s were successfully run then the
call to <code class="highlighter-rouge">.as</code> will discard the result (<code class="highlighter-rouge">List[Unit]</code>) and returns
<code class="highlighter-rouge">ExitCode.Success</code>.</p>

<h3 id="multiple-producer-consumer-with-bounded-buffer-using-semaphores">Multiple producer-consumer with bounded buffer using semaphores</h3>
<p>A more interesting challenge is to introduce the use of bunded buffers. In this
new scenario, each producer must wait for the buffer to have some empty buckets
before inserting new data.</p>

<p>This scenario is solved with two semaphores. First one will keep the count of data
items in the buffer, second one will keep the count of empty buckets. <code class="highlighter-rouge">consumer</code>
will block if no items are in the buffer and will signal about new empty
buckets, <code class="highlighter-rouge">producer</code> will likewise block if no empty buckets are available and
will signal about new data items in the buffer.</p>

<p>Using this approach we have this new implementation (it assumes a buffer size of
<code class="highlighter-rouge">100</code> buckets):</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">java.util.concurrent.atomic.AtomicInteger</span>

<span class="k">import</span> <span class="nn">cats.effect.concurrent.Semaphore</span>
<span class="k">import</span> <span class="nn">cats.effect.</span><span class="o">{</span><span class="nc">ExitCode</span><span class="o">,</span> <span class="nc">IO</span><span class="o">,</span> <span class="nc">IOApp</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">cats.implicits._</span>

<span class="k">import</span> <span class="nn">scala.collection.mutable</span>

<span class="k">object</span> <span class="nc">SemaphoreMultiplesProducerConsumerBoundedQueue</span> <span class="k">extends</span> <span class="nc">IOApp</span> <span class="o">{</span>

  <span class="k">def</span> <span class="n">process</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="kt">:</span> <span class="kt">Sync</span><span class="o">](</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Sync</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">delay</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">10000</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
        <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Processed $i elements"</span><span class="o">)</span>
    <span class="o">}</span>

  <span class="k">val</span> <span class="n">counter</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">AtomicInteger</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">create</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="kt">:</span> <span class="kt">Sync</span><span class="o">]</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Sync</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">delay</span><span class="o">(</span><span class="n">counter</span><span class="o">.</span><span class="n">incrementAndGet</span><span class="o">())</span>

  <span class="k">def</span> <span class="n">producer</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="kt">:</span> <span class="kt">Sync</span><span class="o">](</span><span class="n">id</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">count</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">buffer</span><span class="k">:</span> <span class="kt">mutable.Buffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">],</span> <span class="n">lock</span><span class="k">:</span> <span class="kt">Semaphore</span><span class="o">[</span><span class="kt">F</span><span class="o">],</span> <span class="n">empty</span><span class="k">:</span> <span class="kt">Semaphore</span><span class="o">[</span><span class="kt">F</span><span class="o">],</span> <span class="n">filled</span><span class="k">:</span> <span class="kt">Semaphore</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">for</span> <span class="o">{</span>
      <span class="n">i</span> <span class="k">&lt;-</span> <span class="n">create</span>
      <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">empty</span><span class="o">.</span><span class="n">acquire</span>     <span class="c1">// Wait for some empty bucket
</span>      <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">lock</span><span class="o">.</span><span class="n">withPermit</span> <span class="o">{</span> <span class="c1">// Enter critical section, wait if lock already acquired, release when done
</span>        <span class="nc">Sync</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">delay</span><span class="o">(</span><span class="n">buffer</span><span class="o">.</span><span class="n">append</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>
      <span class="o">}</span>
      <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">filled</span><span class="o">.</span><span class="n">release</span>    <span class="c1">// Signal new item in buffer
</span>      <span class="n">newCount</span> <span class="k">=</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span>
      <span class="k">_</span> <span class="k">&lt;-</span> <span class="k">if</span> <span class="o">(</span><span class="n">newCount</span> <span class="o">%</span> <span class="mi">1000</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="nc">Sync</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">delay</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Producer $id has produced $newCount items"</span><span class="o">))</span> <span class="k">else</span> <span class="nc">Sync</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">unit</span>
      <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">producer</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">newCount</span><span class="o">,</span> <span class="n">buffer</span><span class="o">,</span> <span class="n">lock</span><span class="o">,</span> <span class="n">empty</span><span class="o">,</span> <span class="n">filled</span><span class="o">)</span>
    <span class="o">}</span> <span class="k">yield</span> <span class="o">()</span>

  <span class="k">def</span> <span class="n">consumer</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="kt">:</span> <span class="kt">Sync</span><span class="o">](</span><span class="n">id</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">count</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">buffer</span><span class="k">:</span> <span class="kt">mutable.Buffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">],</span> <span class="n">lock</span><span class="k">:</span> <span class="kt">Semaphore</span><span class="o">[</span><span class="kt">F</span><span class="o">],</span> <span class="n">empty</span><span class="k">:</span> <span class="kt">Semaphore</span><span class="o">[</span><span class="kt">F</span><span class="o">],</span> <span class="n">filled</span><span class="k">:</span> <span class="kt">Semaphore</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">for</span> <span class="o">{</span>
      <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">filled</span><span class="o">.</span><span class="n">acquire</span>    <span class="c1">// Wait for some item in buffer
</span>      <span class="n">i</span> <span class="k">&lt;-</span> <span class="n">lock</span><span class="o">.</span><span class="n">withPermit</span> <span class="o">{</span> <span class="c1">// Enter critical section, wait if lock already acquired, release when done
</span>        <span class="nc">Sync</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">delay</span><span class="o">(</span><span class="n">buffer</span><span class="o">.</span><span class="n">remove</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span>
      <span class="o">}</span>
      <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">empty</span><span class="o">.</span><span class="n">release</span>     <span class="c1">// Signal new empty bucket
</span>      <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">process</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>
      <span class="n">newCount</span> <span class="k">=</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span>
      <span class="k">_</span> <span class="k">&lt;-</span> <span class="k">if</span> <span class="o">(</span><span class="n">newCount</span> <span class="o">%</span> <span class="mi">1000</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="nc">Sync</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">delay</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Consumer $id has consumed $newCount items"</span><span class="o">))</span> <span class="k">else</span> <span class="nc">Sync</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">unit</span>
      <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">consumer</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">newCount</span><span class="o">,</span> <span class="n">buffer</span><span class="o">,</span> <span class="n">lock</span><span class="o">,</span> <span class="n">empty</span><span class="o">,</span> <span class="n">filled</span><span class="o">)</span>
    <span class="o">}</span> <span class="k">yield</span> <span class="o">()</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">run</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">ExitCode</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">for</span> <span class="o">{</span>
      <span class="n">buffer</span> <span class="k">&lt;-</span> <span class="nc">IO</span><span class="o">(</span><span class="k">new</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">ListBuffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">]())</span>
      <span class="n">lock</span> <span class="k">&lt;-</span> <span class="nc">Semaphore</span><span class="o">[</span><span class="kt">IO</span><span class="o">](</span><span class="mi">1</span><span class="o">)</span>
      <span class="n">empty</span> <span class="k">&lt;-</span> <span class="nc">Semaphore</span><span class="o">[</span><span class="kt">IO</span><span class="o">](</span><span class="mi">100</span><span class="o">)</span>
      <span class="n">filled</span> <span class="k">&lt;-</span> <span class="nc">Semaphore</span><span class="o">[</span><span class="kt">IO</span><span class="o">](</span><span class="mi">0</span><span class="o">)</span>
      <span class="n">producers</span> <span class="k">&lt;-</span> <span class="nc">List</span><span class="o">.</span><span class="n">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">11</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">producer</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">buffer</span><span class="o">,</span> <span class="n">lock</span><span class="o">,</span> <span class="n">empty</span><span class="o">,</span> <span class="n">filled</span><span class="o">)).</span><span class="n">pure</span><span class="o">[</span><span class="kt">IO</span><span class="o">]</span> <span class="c1">// 10 producers
</span>      <span class="n">consumers</span> <span class="k">&lt;-</span> <span class="nc">List</span><span class="o">.</span><span class="n">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">11</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">consumer</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">buffer</span><span class="o">,</span> <span class="n">lock</span><span class="o">,</span> <span class="n">empty</span><span class="o">,</span> <span class="n">filled</span><span class="o">)).</span><span class="n">pure</span><span class="o">[</span><span class="kt">IO</span><span class="o">]</span> <span class="c1">// 10 consumers
</span>      <span class="n">res</span> <span class="k">&lt;-</span> <span class="o">(</span><span class="n">producers</span> <span class="o">++</span> <span class="n">consumers</span><span class="o">)</span>
        <span class="o">.</span><span class="n">parSequence</span><span class="o">.</span><span class="n">as</span><span class="o">(</span><span class="nc">ExitCode</span><span class="o">.</span><span class="nc">Success</span><span class="o">)</span> <span class="c1">// Run producers and consumers in parallel until done (likely by user cancelling with CTRL-C)
</span>        <span class="o">.</span><span class="n">handleErrorWith</span> <span class="o">{</span> <span class="n">t</span> <span class="k">=&gt;</span>
          <span class="nc">IO</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Error caught: ${t.getMessage}"</span><span class="o">)).</span><span class="n">as</span><span class="o">(</span><span class="nc">ExitCode</span><span class="o">.</span><span class="nc">Error</span><span class="o">)</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">yield</span> <span class="n">res</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The full implementation of this producer consumer with bounded queue is available
<a href="https://github.com/lrodero/cats-effect-tutorial/blob/replace_tcp_section_with_prodcons/src/main/scala/catsEffectTutorial/producerconsumer/SemaphoreMultiplesProducerConsumerBoundedQueue.scala">here</a>.</p>

<p>The <code class="highlighter-rouge">empty</code> semaphore carries the amount of empty buckets. Initially all buckets
are empty so we assign as many permits as the buffer size <code class="highlighter-rouge">100</code>. The <code class="highlighter-rouge">filled</code>
semaphore carries no permits at the beginning as there is no data items in the
buffer yet. Then <code class="highlighter-rouge">producer</code> and <code class="highlighter-rouge">consumer</code> use them to keep trace of number of
available items/empty buckets in the buffer. Finally we still have to use <code class="highlighter-rouge">lock</code>
to protect access to the shared buffer.</p>

<h3 id="exercise-build-a-concurrent-queue">Exercise: build a concurrent queue</h3>
<p>A <em>concurrent queue</em> is, well, a queue data structure that allows safe
concurrent access. That is, several concurrent processes can safely add and
retrieve data from the queue. It is easy to realize that during the previous
sections we already implemented that kind of functionality, it was
embedded in our <code class="highlighter-rouge">producer</code> and <code class="highlighter-rouge">consumer</code> functions. To build a concurrent queue
we only need to extract from those methods the part that handles the concurrent
access.</p>

<p>A simple concurrent queue with only two methods could be defined as:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.</span><span class="o">{</span><span class="nc">Concurrent</span><span class="o">,</span> <span class="nc">Sync</span><span class="o">}</span>

<span class="k">trait</span> <span class="nc">SimpleConcurrentQueue</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="cm">/** Get and remove first element from queue, blocks if queue empty. */</span>
  <span class="k">def</span> <span class="n">poll</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
  <span class="cm">/** Put element at then end of queue, blocks if queue is bounded and full.*/</span>
  <span class="k">def</span> <span class="n">put</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
<span class="o">}</span>

<span class="c1">// Exercise: implement builder methods in this companion object
</span><span class="k">object</span> <span class="nc">SimpleConcurrentQueue</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">unbounded</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Concurrent:</span> <span class="kt">Sync</span>, <span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">SimpleConcurrentQueue</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">A</span><span class="o">]]</span> <span class="k">=</span> <span class="o">???</span>
  <span class="k">def</span> <span class="n">bounded</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Concurrent:</span> <span class="kt">Sync</span>, <span class="kt">A</span><span class="o">](</span><span class="n">size</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">SimpleConcurrentQueue</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">A</span><span class="o">]]</span> <span class="k">=</span> <span class="o">???</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The exercise is to implement the missing constructor methods we have included in
<code class="highlighter-rouge">SimpleConcurrentQueue</code> companion object. A possible implementation is given
<a href="https://github.com/lrodero/cats-effect-tutorial/blob/replace_tcp_section_with_prodcons/src/main/scala/catsEffectTutorial/producerconsumer/exerciseconcurrentqueue/SimpleConcurrentQueue.scala">here</a> for reference.</p>

<p>Finally, we propose you to write a more complete concurrent queue
implementation with these definitions:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.</span><span class="o">{</span><span class="nc">Concurrent</span><span class="o">,</span> <span class="nc">Sync</span><span class="o">}</span>

<span class="k">trait</span> <span class="nc">ConcurrentQueue</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="cm">/** Get and remove first element from queue, blocks if queue empty. */</span>
  <span class="k">def</span> <span class="n">poll</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
  <span class="cm">/** Get and remove first `n` elements from queue, blocks if less than `n` items are available in queue. Error raised if n &lt; 0. */</span>
  <span class="k">def</span> <span class="n">pollN</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span>
  <span class="cm">/** Get, but not remove, first element in queue, blocks if queue empty. */</span>
  <span class="k">def</span> <span class="n">peek</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
  <span class="cm">/** Get, but not remove, first `n` elements in queue, blocks if less than `n` items are available in queue. Error raised if n &lt; 0. */</span>
  <span class="k">def</span> <span class="n">peekN</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span>
  <span class="cm">/** Put element at then end of queue, blocks if queue is bounded and full. */</span>
  <span class="k">def</span> <span class="n">put</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
  <span class="cm">/** Puts elements at the end of the queue, blocks if queue is bounded and does not have spare size for all items. */</span>
  <span class="k">def</span> <span class="n">putN</span><span class="o">(</span><span class="n">as</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
  <span class="cm">/** Try to get and remove first element from queue, immediately returning `F[None]` if queue empty. Non-blocking. */</span>
  <span class="k">def</span> <span class="n">tryPoll</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span>
  <span class="cm">/** Try to get and remove first `n` elements from queue, immediately returning `F[None]` if less than `n` items are available in queue. Non-blocking. Error raised if n &lt; 0. */</span>
  <span class="k">def</span> <span class="n">tryPollN</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]]]</span>
  <span class="cm">/** Try to get, but not remove, first element from queue, immediately returning `F[None]` if queue empty. Non-blocking. */</span>
  <span class="k">def</span> <span class="n">tryPeek</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span>
  <span class="cm">/** Try to get, but not remove, first  `n` elements from queue, immediately returning `F[None]` if less than `n` items are available in queue. Non-blocking. Error raised if n &lt; 0. */</span>
  <span class="k">def</span> <span class="n">tryPeekN</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]]]</span>
  <span class="cm">/** Try to put element at the end of queue, immediately returning `F[false]` if queue is bounded and full. Non-blocking. */</span>
  <span class="k">def</span> <span class="n">tryPut</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span>
  <span class="cm">/** Try to put elements in list at the end of queue, immediately returning `F[false]` if queue is bounded and does not have spare size for all items. Non-blocking. */</span>
  <span class="k">def</span> <span class="n">tryPutN</span><span class="o">(</span><span class="n">as</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span>
  <span class="cm">/** Returns # of items in queue. Non-blocking. */</span>
  <span class="k">def</span> <span class="n">size</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span>
  <span class="cm">/** Returns `F[true]` if queue empty, `F[false]` otherwise. Non-blocking. */</span>
  <span class="k">def</span> <span class="n">isEmpty</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span>
<span class="o">}</span>

<span class="cm">/**
 * Specific methods for bounded concurrent queues.
 */</span>
<span class="k">trait</span> <span class="nc">BoundedConcurrentQueue</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">ConcurrentQueue</span> <span class="o">[</span><span class="kt">F</span>, <span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="cm">/** Remaining empty buckets. Non-blocking.*/</span>
  <span class="k">def</span> <span class="n">emptyBuckets</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span>
  <span class="cm">/** Returns `F[true]` if queue full, `F[false]` otherwise. Non-blocking. */</span>
  <span class="k">def</span> <span class="n">isFull</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span>
<span class="o">}</span>

<span class="c1">// Exercise: implement builder methods in this companion object
</span><span class="k">object</span> <span class="nc">ConcurrentQueue</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">unbounded</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Concurrent:</span> <span class="kt">Sync</span>, <span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">ConcurrentQueue</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">A</span><span class="o">]]</span> <span class="k">=</span> <span class="o">???</span>
  <span class="k">def</span> <span class="n">bounded</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Concurrent:</span> <span class="kt">Sync</span>, <span class="kt">A</span><span class="o">](</span><span class="n">size</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">BoundedConcurrentQueue</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">A</span><span class="o">]]</span> <span class="k">=</span> <span class="o">???</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Note that now bounded concurrent queues have their own type
<code class="highlighter-rouge">BoundedConcurrentQueue</code> which extends <code class="highlighter-rouge">ConcurrentQueue</code> with some functions
specific to them. As before, you should try to implement the builder methods in
companion object <code class="highlighter-rouge">ConcurrentQueue</code>. Tip: we have not reviewed all methods that
cats-effect’s <code class="highlighter-rouge">Semaphore</code> has to offer. Take a look to <code class="highlighter-rouge">Semaphore</code>
<a href="https://typelevel.org/cats-effect/api/cats/effect/concurrent/Semaphore.html">API</a>
as you will find some new useful methods there.</p>

<p>A possible implementation of the concurrent queue is given
<a href="https://github.com/lrodero/cats-effect-tutorial/blob/replace_tcp_section_with_prodcons/src/main/scala/catsEffectTutorial/producerconsumer/exerciseconcurrentqueue/ConcurrentQueue.scala">here</a>
for reference. <strong>NOTE</strong> that concurrent queue implementation is not intended for
high-throughput requirements, and it has not been tested in production
environments.  For a production-ready, high-performance concurrent queue it is
strongly advised to take a look to <a href="https://monix.io/api/current/monix/catnap/ConcurrentQueue.html">Monix’s concurrent
queue</a>, which is
cats-effect compatible.</p>

<h2 id="conclusion">Conclusion</h2>

<p>With all this we have covered a good deal of what cats-effect has to offer (but
not all!). Now you are ready to use to create code that operate side effects in
a purely functional manner. Enjoy the ride!</p>


<link rel="stylesheet" type="text/css" href="/cats-effect/css/toc.css"></link>
<script type="text/javascript" src="/cats-effect/js/toc.js"></script>
</section></div></div></div></div><script src="/cats-effect/highlight/highlight.pack.js"></script><script>
// For all code blocks, copy the language from the containing div
// to the inner code tag (where hljs expects it to be)
const langPrefix = 'language-';
document.querySelectorAll(`div[class^='${langPrefix}']`).forEach(function(div) {
  div.classList.forEach(function(cssClass) {
    if (cssClass.startsWith(langPrefix)) {
      const lang = cssClass.substring(langPrefix.length);
      div.querySelectorAll('pre code').forEach(function(code) {
        code.classList.add(lang);
      });
    }
  });
});

hljs.configure({languages:['scala','java','bash']});
hljs.initHighlightingOnLoad();
      </script><script src="/cats-effect/js/toc.js"></script><script>console.info('\x57\x65\x62\x73\x69\x74\x65\x20\x62\x75\x69\x6c\x74\x20\x77\x69\x74\x68\x3a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x5f\x5f\x20\x20\x20\x20\x5f\x5f\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x5f\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x5f\x20\x5f\x5f\x0a\x20\x20\x20\x5f\x5f\x5f\x5f\x5f\x2f\x20\x2f\x5f\x20\x20\x2f\x20\x2f\x5f\x20\x20\x20\x20\x20\x20\x5f\x5f\x5f\x5f\x20\x5f\x5f\x5f\x20\x20\x28\x5f\x29\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x20\x20\x5f\x5f\x5f\x5f\x5f\x28\x5f\x29\x20\x2f\x5f\x5f\x5f\x5f\x20\x20\x5f\x5f\x5f\x5f\x5f\x0a\x20\x20\x2f\x20\x5f\x5f\x5f\x2f\x20\x5f\x5f\x20\x5c\x2f\x20\x5f\x5f\x2f\x5f\x5f\x5f\x5f\x5f\x2f\x20\x5f\x5f\x20\x60\x5f\x5f\x20\x5c\x2f\x20\x2f\x20\x5f\x5f\x5f\x2f\x20\x5f\x5f\x5f\x2f\x20\x5f\x5f\x20\x5c\x2f\x20\x5f\x5f\x5f\x2f\x20\x2f\x20\x5f\x5f\x2f\x20\x5f\x20\x5c\x2f\x20\x5f\x5f\x5f\x2f\x0a\x20\x28\x5f\x5f\x20\x20\x29\x20\x2f\x5f\x2f\x20\x2f\x20\x2f\x5f\x2f\x5f\x5f\x5f\x5f\x5f\x2f\x20\x2f\x20\x2f\x20\x2f\x20\x2f\x20\x2f\x20\x2f\x20\x2f\x5f\x5f\x2f\x20\x2f\x20\x20\x2f\x20\x2f\x5f\x2f\x20\x28\x5f\x5f\x20\x20\x29\x20\x2f\x20\x2f\x5f\x2f\x20\x20\x5f\x5f\x28\x5f\x5f\x20\x20\x29\x0a\x2f\x5f\x5f\x5f\x5f\x2f\x5f\x2e\x5f\x5f\x5f\x2f\x5c\x5f\x5f\x2f\x20\x20\x20\x20\x20\x2f\x5f\x2f\x20\x2f\x5f\x2f\x20\x2f\x5f\x2f\x5f\x2f\x5c\x5f\x5f\x5f\x2f\x5f\x2f\x20\x20\x20\x5c\x5f\x5f\x5f\x5f\x2f\x5f\x5f\x5f\x5f\x2f\x5f\x2f\x5c\x5f\x5f\x2f\x5c\x5f\x5f\x5f\x2f\x5f\x5f\x5f\x5f\x2f\x0a\x0a\x68\x74\x74\x70\x73\x3a\x2f\x2f\x34\x37\x64\x65\x67\x2e\x67\x69\x74\x68\x75\x62\x2e\x69\x6f\x2f\x73\x62\x74\x2d\x6d\x69\x63\x72\x6f\x73\x69\x74\x65\x73')</script><script>((window.gitter = {}).chat = {}).options = {
room: 'typelevel/cats-effect'};</script><script src="https://sidecar.gitter.im/dist/sidecar.v1.js"></script><script src="/cats-effect/js/docs.js"></script></body></html>